diff --git a/src/main/java/mx/unam/ciencias/edd/ArbolAVL.java b/src/main/java/mx/unam/ciencias/edd/ArbolAVL.java
index e4cfd15..cfff3db 100644
--- a/src/main/java/mx/unam/ciencias/edd/ArbolAVL.java
+++ b/src/main/java/mx/unam/ciencias/edd/ArbolAVL.java
@@ -23,6 +23,7 @@ public class ArbolAVL<T extends Comparable<T>>
          */
         public VerticeAVL(T elemento) {
             // Aquí va su código.
+            super(elemento);
         }
 
         /**
@@ -31,16 +32,20 @@ public class ArbolAVL<T extends Comparable<T>>
          */
         @Override public int altura() {
             // Aquí va su código.
+            return altura;
         }
 
+
         /**
          * Regresa una representación en cadena del vértice AVL.
          * @return una representación en cadena del vértice AVL.
          */
         @Override public String toString() {
             // Aquí va su código.
+            return String.format("%s %d/%d", elemento.toString(), altura, balance(this));
         }
 
+
         /**
          * Compara el vértice con otro objeto. La comparación es
          * <em>recursiva</em>.
@@ -56,6 +61,7 @@ public class ArbolAVL<T extends Comparable<T>>
                 return false;
             @SuppressWarnings("unchecked") VerticeAVL vertice = (VerticeAVL)objeto;
             // Aquí va su código.
+            return ((altura == vertice.altura) && (super.equals(vertice)));
         }
     }
 
@@ -72,6 +78,7 @@ public class ArbolAVL<T extends Comparable<T>>
      */
     public ArbolAVL(Coleccion<T> coleccion) {
         // Aquí va su código.
+        super(coleccion);
     }
 
     /**
@@ -81,6 +88,11 @@ public class ArbolAVL<T extends Comparable<T>>
      */
     @Override protected Vertice nuevoVertice(T elemento) {
         // Aquí va su código.
+        return new VerticeAVL(elemento);
+    }
+
+    private VerticeAVL verticeAVL(VerticeArbolBinario<T> vertice) {
+        return (VerticeAVL) vertice;
     }
 
     /**
@@ -91,6 +103,66 @@ public class ArbolAVL<T extends Comparable<T>>
      */
     @Override public void agrega(T elemento) {
         // Aquí va su código.
+        super.agrega(elemento);
+        rebalancear(verticeAVL(ultimoAgregado.padre));
+    }
+
+    private void rebalancear(VerticeAVL vertice) {
+        if(vertice == null){
+            return;
+        }
+            
+        transformaLaAltura(vertice);
+        if(balance(vertice) == 2){
+            VerticeAVL hIzquierdo = verticeAVL(vertice.izquierdo);
+
+            if(balance(hIzquierdo) == -1){
+                super.giraIzquierda(hIzquierdo);
+                transformaLaAltura(hIzquierdo);
+            }
+
+            super.giraDerecha(vertice);
+            transformaLaAltura(hIzquierdo);
+            transformaLaAltura(vertice);
+        }
+
+        if(balance(vertice) == -2){
+            VerticeAVL hderecho = verticeAVL(vertice.derecho);
+
+            if(balance(hderecho) == 1){
+                super.giraDerecha(hderecho);
+                transformaLaAltura(hderecho);
+            }
+
+            super.giraIzquierda(vertice);
+            transformaLaAltura(hderecho);
+            transformaLaAltura(vertice);
+        }
+        rebalancear(verticeAVL(vertice.padre));
+
+    }
+
+    private int altura(VerticeAVL vertice){
+        if(vertice == null){
+            return -1;
+        }else{
+            return vertice.altura;
+        }
+    }
+
+    private int balance(VerticeAVL vertice){
+        return altura(verticeAVL(vertice.izquierdo)) - altura(verticeAVL(vertice.derecho));
+    }
+
+    private void transformaLaAltura(VerticeAVL vertice){
+        vertice.altura = 1 + maximo(altura(verticeAVL(vertice.izquierdo)), altura(verticeAVL(vertice.derecho)));
+    }
+
+    public static final int maximo(int a, int b){
+        if(a < b){
+            a = b;
+        } 
+        return a;
     }
 
     /**
@@ -100,6 +172,19 @@ public class ArbolAVL<T extends Comparable<T>>
      */
     @Override public void elimina(T elemento) {
         // Aquí va su código.
+        VerticeAVL vertice = verticeAVL(busca(elemento));
+        if(vertice == null){
+            return;
+        }
+            
+        elementos--;
+        if((vertice.izquierdo != null) && (vertice.derecho != null)){
+            vertice = verticeAVL(intercambiaEliminable(vertice));
+        }
+            
+        eliminaVertice(vertice);
+        rebalancear(verticeAVL(vertice.padre));
+
     }
 
     /**
diff --git a/src/main/java/mx/unam/ciencias/edd/ArbolBinario.java b/src/main/java/mx/unam/ciencias/edd/ArbolBinario.java
index e04bda5..826cb83 100644
--- a/src/main/java/mx/unam/ciencias/edd/ArbolBinario.java
+++ b/src/main/java/mx/unam/ciencias/edd/ArbolBinario.java
@@ -30,6 +30,7 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
          */
         protected Vertice(T elemento) {
             // Aquí va su código.
+            this.elemento = elemento;
         }
 
         /**
@@ -39,6 +40,7 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
          */
         @Override public boolean hayPadre() {
             // Aquí va su código.
+            return padre != null;
         }
 
         /**
@@ -48,6 +50,7 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
          */
         @Override public boolean hayIzquierdo() {
             // Aquí va su código.
+            return izquierdo != null;
         }
 
         /**
@@ -57,6 +60,7 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
          */
         @Override public boolean hayDerecho() {
             // Aquí va su código.
+            return derecho != null;
         }
 
         /**
@@ -66,6 +70,11 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
          */
         @Override public VerticeArbolBinario<T> padre() {
             // Aquí va su código.
+            if(padre == null){
+                throw new NoSuchElementException();
+            }
+
+            return padre;
         }
 
         /**
@@ -75,6 +84,11 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
          */
         @Override public VerticeArbolBinario<T> izquierdo() {
             // Aquí va su código.
+            if(izquierdo == null){
+                throw new NoSuchElementException();
+            }
+
+            return izquierdo;
         }
 
         /**
@@ -84,6 +98,11 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
          */
         @Override public VerticeArbolBinario<T> derecho() {
             // Aquí va su código.
+            if(derecho == null){
+                throw new NoSuchElementException();
+            }
+
+            return derecho;
         }
 
         /**
@@ -92,6 +111,22 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
          */
         @Override public int altura() {
             // Aquí va su código.
+            return altura(this);
+        }
+
+        private int altura(Vertice v) {
+            if(v == null){
+                return -1;
+            }
+
+            int altIzq = altura(v.izquierdo) + 1;
+            int altDer = altura(v.derecho) + 1;
+
+            if(altIzq >= altDer){
+                return altIzq;
+            }
+
+            return altDer;
         }
 
         /**
@@ -100,6 +135,12 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
          */
         @Override public int profundidad() {
             // Aquí va su código.
+            if(padre == null){
+                return 0;
+            }else{
+                return 1 + padre.profundidad();
+            }
+            
         }
 
         /**
@@ -108,6 +149,7 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
          */
         @Override public T get() {
             // Aquí va su código.
+            return elemento;
         }
 
         /**
@@ -125,6 +167,34 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
                 return false;
             @SuppressWarnings("unchecked") Vertice vertice = (Vertice)objeto;
             // Aquí va su código.
+            if(this == null || vertice == null){
+                return false;
+            }
+
+            if(elemento == null && vertice.elemento == null){
+                return true;
+            }
+
+
+            boolean derechote = true;
+            if(derecho != null){
+                derechote = derecho.equals(vertice.derecho);
+            }
+
+
+            boolean izquierdote = true;
+            if(izquierdo != null){
+                izquierdote = izquierdo.equals(vertice.izquierdo);
+            }
+
+
+            if(elemento != null && elemento.equals(vertice.elemento) && derechote && izquierdote){
+                return true;
+            }else{
+                return false;
+            }
+
+
         }
 
         /**
@@ -133,6 +203,7 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
          */
         @Override public String toString() {
             // Aquí va su código.
+            return String.format("%s", elemento);
         }
     }
 
@@ -154,6 +225,9 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
      */
     public ArbolBinario(Coleccion<T> coleccion) {
         // Aquí va su código.
+        for(T elem: coleccion){
+            agrega(elem);
+        }
     }
 
     /**
@@ -176,6 +250,12 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
      */
     public int altura() {
         // Aquí va su código.
+        if(raiz == null){
+            return -1;
+        }else{
+            return raiz.altura();
+        }
+
     }
 
     /**
@@ -184,6 +264,7 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
      */
     @Override public int getElementos() {
         // Aquí va su código.
+        return elementos;
     }
 
     /**
@@ -194,6 +275,12 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
      */
     @Override public boolean contiene(T elemento) {
         // Aquí va su código.
+        if(busca(elemento) == null){
+            return false;
+        }else{
+            return true;
+        }
+
     }
 
     /**
@@ -205,6 +292,24 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
      */
     public VerticeArbolBinario<T> busca(T elemento) {
         // Aquí va su código.
+        return busca(elemento, raiz);
+    }
+
+    private VerticeArbolBinario<T> busca(T elemento, Vertice vertice) {
+        if (vertice == null)
+            return null;
+
+        if (vertice.elemento.equals(elemento))
+            return vertice;
+
+        VerticeArbolBinario<T> verticeDer = busca(elemento, vertice.derecho);
+        VerticeArbolBinario<T> verticeIzq = busca(elemento, vertice.izquierdo);
+        
+
+        if (verticeIzq != null)
+            return verticeIzq;
+
+        return verticeDer;
     }
 
     /**
@@ -214,6 +319,12 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
      */
     public VerticeArbolBinario<T> raiz() {
         // Aquí va su código.
+        if(raiz == null){
+            throw new NoSuchElementException();
+        }
+
+        return raiz;
+
     }
 
     /**
@@ -223,6 +334,12 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
      */
     @Override public boolean esVacia() {
         // Aquí va su código.
+        if(raiz == null){
+            return true;
+        }else{
+            return false;
+        }
+            
     }
 
     /**
@@ -230,6 +347,8 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
      */
     @Override public void limpia() {
         // Aquí va su código.
+        raiz = null;
+        elementos = 0;
     }
 
     /**
@@ -244,6 +363,12 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
         @SuppressWarnings("unchecked")
             ArbolBinario<T> arbol = (ArbolBinario<T>)objeto;
         // Aquí va su código.
+        if(raiz == null && arbol.raiz == null){
+            return true;
+        }
+        
+        return raiz.equals(arbol.raiz);
+
     }
 
     /**
@@ -252,8 +377,66 @@ public abstract class ArbolBinario<T> implements Coleccion<T> {
      */
     @Override public String toString() {
         // Aquí va su código.
+        return toString(this);
+    }
+
+    private String toString(ArbolBinario<T> arbol) {
+	    if ( arbol.raiz == null ){
+            return "";
+        }
+		    
+
+	    int[] arreglo = new int[arbol.altura() + 1];
+	    for(int i = 0; i < arbol.altura() + 1; i++){
+		    arreglo[i] = 0;
+	    }
+
+	    return toString(arbol.raiz, 0, arreglo);
     }
 
+    private String toString(Vertice v, int nivel, int[] arreglo) {
+	    String davinci = v.toString() + "\n";
+
+	    arreglo[nivel] = 1;
+
+	    if(v.izquierdo != null && v.derecho != null){
+		    davinci += dibujaEspacios(nivel, arreglo);
+		    davinci += "├─›";
+		    davinci += toString(v.izquierdo, nivel + 1, arreglo);
+		    davinci += dibujaEspacios(nivel, arreglo);
+		    davinci += "└─»";
+		    arreglo[nivel] = 0;
+		    davinci += toString(v.derecho, nivel + 1, arreglo);
+	    }else if(v.izquierdo != null){
+		    davinci += dibujaEspacios(nivel, arreglo);
+		    davinci += "└─›";
+		    arreglo[nivel] = 0;
+		    davinci += toString(v.izquierdo, nivel + 1, arreglo);
+	    }else if(v.derecho != null){
+		    davinci += dibujaEspacios(nivel, arreglo);
+		    davinci += "└─»";
+		    arreglo[nivel] = 0;
+		    davinci += toString(v.derecho, nivel + 1, arreglo);
+	    }
+	    return davinci;
+    }
+
+    private String dibujaEspacios(int nivel, int[] arreglo) {
+	    String s = "";
+
+	    for(int i = 0; i < nivel; i++){
+		    if( arreglo[i] == 1 ){
+			    s += "│  ";
+		    }else{
+			    s += "   ";
+		    }
+	    }
+
+	    return s;
+    }
+
+    
+
     /**
      * Convierte el vértice (visto como instancia de {@link
      * VerticeArbolBinario}) en vértice (visto como instancia de {@link
diff --git a/src/main/java/mx/unam/ciencias/edd/ArbolBinarioCompleto.java b/src/main/java/mx/unam/ciencias/edd/ArbolBinarioCompleto.java
index 651a4da..5d5fc7a 100644
--- a/src/main/java/mx/unam/ciencias/edd/ArbolBinarioCompleto.java
+++ b/src/main/java/mx/unam/ciencias/edd/ArbolBinarioCompleto.java
@@ -19,16 +19,38 @@ public class ArbolBinarioCompleto<T> extends ArbolBinario<T> {
         /* Inicializa al iterador. */
         private Iterador() {
             // Aquí va su código.
+            cola = new Cola<Vertice>();
+
+            if(raiz != null){
+                cola.mete(raiz);
+            }
+		
         }
 
         /* Nos dice si hay un elemento siguiente. */
         @Override public boolean hasNext() {
             // Aquí va su código.
+            if(cola.esVacia()){
+                return false;
+            }else{
+                return true;
+            }
         }
 
         /* Regresa el siguiente elemento en orden BFS. */
         @Override public T next() {
             // Aquí va su código.
+            Vertice prov = cola.saca(); 
+
+            if(prov.izquierdo != null){
+                cola.mete(prov.izquierdo);   
+            }
+
+            if(prov.derecho != null){
+                cola.mete(prov.derecho);    
+            }
+
+            return prov.elemento;
         }
     }
 
@@ -57,6 +79,49 @@ public class ArbolBinarioCompleto<T> extends ArbolBinario<T> {
      */
     @Override public void agrega(T elemento) {
         // Aquí va su código.
+        if(elemento == null){
+            throw new IllegalArgumentException();
+        }
+
+    	Vertice verticeD = nuevoVertice(elemento);
+	    elementos++;
+
+	    if(raiz == null){
+		    raiz = verticeD;
+	    }else{
+		    Vertice verticeFinal = getPrimerVerticeConHoyo(raiz);
+		    if((elementos) % 2 == 0 ){
+			    verticeFinal.izquierdo = verticeD;
+			    verticeD.padre = verticeFinal;
+		    }else{
+			    verticeFinal.derecho = verticeD;
+			    verticeD.padre = verticeFinal;
+		    }
+	    }
+    }
+
+    private Vertice getPrimerVerticeConHoyo(Vertice v) {
+	    Cola<Vertice> cola = new Cola<Vertice>();
+	    cola.mete(v);
+
+	    while(!cola.esVacia()){
+		    Vertice temp;
+		    temp = cola.saca();
+
+		    if(temp.izquierdo == null){
+			    return temp;
+		    }else{
+			    cola.mete(temp.izquierdo);
+		    }
+
+		    if(temp.derecho == null){
+			    return temp;
+		    }else{ 
+			    cola.mete(temp.derecho);
+		    }
+	    }
+
+	    return null;
     }
 
     /**
@@ -67,6 +132,52 @@ public class ArbolBinarioCompleto<T> extends ArbolBinario<T> {
      */
     @Override public void elimina(T elemento) {
         // Aquí va su código.
+        Vertice vertice = vertice(busca(elemento));
+
+        if (vertice == null)
+            return;
+
+        elementos--;
+
+        if(elementos == 0){
+            raiz = null;
+            return;
+        }
+
+        Vertice ultimoVertice = vertice(ultimoVerticeAgregado());
+        vertice.elemento = ultimoVertice.elemento;
+
+        if(ultimoVertice.padre.izquierdo == ultimoVertice){
+            ultimoVertice.padre.izquierdo = null;
+        }else{
+            ultimoVertice.padre.derecho = null;
+        }
+        
+            
+        
+    }
+
+    private VerticeArbolBinario<T> ultimoVerticeAgregado() {
+        Cola<Vertice> cola = new Cola<Vertice>();
+        cola.mete(raiz);
+
+        Vertice ultimoVert = raiz;
+        Vertice verticeAct;
+
+        while(!cola.esVacia()){
+            verticeAct = cola.saca();
+            ultimoVert = verticeAct;
+
+            if(verticeAct.izquierdo != null){
+                cola.mete(verticeAct.izquierdo);
+            }
+                
+            if(verticeAct.derecho != null){
+                cola.mete(verticeAct.derecho);
+            }  
+        }
+
+        return ultimoVert;
     }
 
     /**
@@ -76,6 +187,12 @@ public class ArbolBinarioCompleto<T> extends ArbolBinario<T> {
      */
     @Override public int altura() {
         // Aquí va su código.
+        if(raiz == null){
+            return -1;
+        }
+
+        return (int) (Math.floor(Math.log(elementos)/Math.log(2)));
+		
     }
 
     /**
@@ -85,6 +202,29 @@ public class ArbolBinarioCompleto<T> extends ArbolBinario<T> {
      */
     public void bfs(AccionVerticeArbolBinario<T> accion) {
         // Aquí va su código.
+        if(raiz == null){
+            return;
+        }
+		    
+	    Cola <Vertice> cola = new Cola<Vertice>();
+	    cola.mete(raiz);
+
+	    while (!cola.esVacia()){
+		    Vertice aux;
+		   
+		    aux = cola.saca();
+		    accion.actua(aux);
+
+		    if(aux.izquierdo != null){
+                cola.mete(aux.izquierdo);
+            }
+			    
+		    if(aux.derecho != null){
+                cola.mete(aux.derecho);
+            }
+
+	    }
+
     }
 
     /**
diff --git a/src/main/java/mx/unam/ciencias/edd/ArbolBinarioOrdenado.java b/src/main/java/mx/unam/ciencias/edd/ArbolBinarioOrdenado.java
index 5e014ab..d36ead3 100644
--- a/src/main/java/mx/unam/ciencias/edd/ArbolBinarioOrdenado.java
+++ b/src/main/java/mx/unam/ciencias/edd/ArbolBinarioOrdenado.java
@@ -26,16 +26,47 @@ public class ArbolBinarioOrdenado<T extends Comparable<T>>
         /* Inicializa al iterador. */
         private Iterador() {
             // Aquí va su código.
+            pila = new Pila<Vertice>();
+            Vertice r = raiz;
+            
+            if (r == null){
+                return;
+            }
+
+            while(r != null){
+                pila.mete(r);
+                r = r.izquierdo;
+            }
+
         }
 
         /* Nos dice si hay un elemento siguiente. */
         @Override public boolean hasNext() {
             // Aquí va su código.
+            if(pila.esVacia()){
+                return false;
+            }else{
+                return true;
+            }
         }
 
         /* Regresa el siguiente elemento en orden DFS in-order. */
         @Override public T next() {
             // Aquí va su código.
+            Vertice prov = pila.saca(); 
+
+            if(prov.derecho != null) {
+                Vertice asistente = prov.derecho;
+                pila.mete(asistente);
+
+                while((asistente = asistente.izquierdo) != null){
+                    pila.mete(asistente);
+                }
+                    
+            }
+
+            return prov.elemento;
+            
         }
     }
 
@@ -70,6 +101,45 @@ public class ArbolBinarioOrdenado<T extends Comparable<T>>
      */
     @Override public void agrega(T elemento) {
         // Aquí va su código.
+        if(elemento == null){
+            throw new IllegalArgumentException();
+        }
+
+        Vertice verticeNuevo = nuevoVertice(elemento);
+        elementos++;
+
+        if(raiz == null){
+            raiz = verticeNuevo;
+        }else{
+            agrega(raiz, verticeNuevo);
+        }
+        
+        ultimoAgregado = verticeNuevo;
+    }
+
+    private void agrega(Vertice primero, Vertice segundo) {
+
+	    if(primero == null){
+            return;
+        }
+		    
+	    if (segundo.elemento.compareTo(primero.elemento) <= 0){
+		    if(primero.izquierdo == null){
+			    primero.izquierdo = segundo;
+			    segundo.padre = primero;
+		    }else{
+			    agrega(primero.izquierdo, segundo);
+		    }
+
+	    }else{
+		    if(primero.derecho == null){
+			    primero.derecho = segundo;
+			    segundo.padre = primero;
+		    }else{
+			    agrega(primero.derecho, segundo);
+		    }
+            
+	    }
     }
 
     /**
@@ -80,6 +150,23 @@ public class ArbolBinarioOrdenado<T extends Comparable<T>>
      */
     @Override public void elimina(T elemento) {
         // Aquí va su código.
+        if(elemento == null){
+            return;
+        }
+
+        Vertice buscado = vertice(busca(elemento));
+
+        if(buscado == null){
+            return;
+        }
+
+
+        elementos--;
+        if(buscado.izquierdo != null && buscado.derecho != null){
+            buscado = intercambiaEliminable(buscado);
+            }
+        eliminaVertice(buscado);
+        
     }
 
     /**
@@ -93,6 +180,20 @@ public class ArbolBinarioOrdenado<T extends Comparable<T>>
      */
     protected Vertice intercambiaEliminable(Vertice vertice) {
         // Aquí va su código.
+        Vertice maximo = maximoEnSubarbol(vertice.izquierdo);
+	    T elem = vertice.elemento;
+
+	    vertice.elemento = maximo.elemento;
+	    maximo.elemento = elem;
+
+	    return maximo;
+    }
+
+    protected Vertice maximoEnSubarbol(Vertice vertice) {
+        while(vertice.hayDerecho()) {
+            vertice = vertice.derecho;
+        }
+        return vertice;
     }
 
     /**
@@ -103,6 +204,29 @@ public class ArbolBinarioOrdenado<T extends Comparable<T>>
      */
     protected void eliminaVertice(Vertice vertice) {
         // Aquí va su código.
+        Vertice hijo;
+        if(vertice.izquierdo != null){
+            hijo = vertice.izquierdo;
+        }else{
+            hijo = vertice.derecho;
+        }
+
+        if(vertice.padre == null){
+            raiz = hijo;
+        }else{
+
+            if(vertice.padre.izquierdo == vertice){
+                vertice.padre.izquierdo = hijo;
+            }else{
+                vertice.padre.derecho = hijo;
+            }
+            
+        }
+        if (hijo != null){
+            hijo.padre = vertice.padre;
+        }
+        
+        
     }
 
     /**
@@ -114,6 +238,25 @@ public class ArbolBinarioOrdenado<T extends Comparable<T>>
      */
     @Override public VerticeArbolBinario<T> busca(T elemento) {
         // Aquí va su código.
+        return busca(elemento, raiz);
+    }
+
+    private VerticeArbolBinario<T> busca(T elemento, Vertice vertice){
+        if(vertice == null){
+            return null;
+        }
+            
+        if (elemento.equals(vertice.elemento)){
+            return vertice;
+        }
+            
+
+        if (elemento.compareTo(vertice.elemento) <= 0){
+            return busca(elemento, vertice.izquierdo);
+        }
+            
+        return busca(elemento, vertice.derecho);
+    
     }
 
     /**
@@ -129,6 +272,7 @@ public class ArbolBinarioOrdenado<T extends Comparable<T>>
      */
     public VerticeArbolBinario<T> getUltimoVerticeAgregado() {
         // Aquí va su código.
+        return ultimoAgregado;
     }
 
     /**
@@ -138,6 +282,34 @@ public class ArbolBinarioOrdenado<T extends Comparable<T>>
      */
     public void giraDerecha(VerticeArbolBinario<T> vertice) {
         // Aquí va su código.
+        Vertice vGiraDerecha = vertice(vertice);
+
+	    if(vGiraDerecha.izquierdo == null || vGiraDerecha == null){
+            return;
+        }
+		    
+	    Vertice izquierdo = vGiraDerecha.izquierdo;
+	    izquierdo.padre = vGiraDerecha.padre;
+
+	    if (vGiraDerecha.padre != null){
+		    if(vGiraDerecha.equals(vGiraDerecha.padre.izquierdo)){
+			    vGiraDerecha.padre.izquierdo = izquierdo;
+		    }else{ 
+			    vGiraDerecha.padre.derecho = izquierdo;
+		    }
+	    }else{
+		    raiz = izquierdo;
+	    }
+
+	    vGiraDerecha.padre = izquierdo;
+	    vGiraDerecha.izquierdo = izquierdo.derecho; 
+
+	    if(vGiraDerecha.izquierdo != null){
+		    izquierdo.derecho.padre = vGiraDerecha;
+	    }
+
+	    izquierdo.derecho = vGiraDerecha;
+
     }
 
     /**
@@ -147,6 +319,33 @@ public class ArbolBinarioOrdenado<T extends Comparable<T>>
      */
     public void giraIzquierda(VerticeArbolBinario<T> vertice) {
         // Aquí va su código.
+        Vertice vGiraIzquierda = vertice(vertice);
+
+        if(vGiraIzquierda.derecho == null){
+            return;
+        }
+            
+        Vertice hijo = vGiraIzquierda.derecho;
+        hijo.padre = vGiraIzquierda.padre;
+
+        if(vGiraIzquierda.padre == null){
+            raiz = hijo;
+        }else{
+            if(vGiraIzquierda.padre.derecho == vGiraIzquierda){
+                vGiraIzquierda.padre.derecho = hijo;
+            }else{
+                vGiraIzquierda.padre.izquierdo = hijo;
+            }
+            
+        }
+
+        vGiraIzquierda.derecho = hijo.izquierdo;
+
+        if(vGiraIzquierda.derecho != null){
+            vGiraIzquierda.derecho.padre = vGiraIzquierda;
+        }
+        hijo.izquierdo = vGiraIzquierda;
+        vGiraIzquierda.padre = hijo;
     }
 
     /**
@@ -156,6 +355,19 @@ public class ArbolBinarioOrdenado<T extends Comparable<T>>
      */
     public void dfsPreOrder(AccionVerticeArbolBinario<T> accion) {
         // Aquí va su código.
+        dfsPreOrder(accion, raiz);
+    }
+
+    private void dfsPreOrder(AccionVerticeArbolBinario<T> accion, Vertice vertice) {
+        if(vertice == null){
+            return;
+        }
+            
+        accion.actua(vertice);
+
+        dfsPreOrder(accion, vertice.izquierdo);
+        dfsPreOrder(accion, vertice.derecho);
+
     }
 
     /**
@@ -165,8 +377,19 @@ public class ArbolBinarioOrdenado<T extends Comparable<T>>
      */
     public void dfsInOrder(AccionVerticeArbolBinario<T> accion) {
         // Aquí va su código.
+        dfsInOrder(accion, raiz);
     }
 
+    private void dfsInOrder(AccionVerticeArbolBinario<T> accion, Vertice vertice) {
+        if(vertice == null){
+            return;
+        }
+
+        dfsInOrder(accion, vertice.izquierdo);
+
+        accion.actua(vertice);
+        dfsInOrder(accion, vertice.derecho);
+    }
     /**
      * Realiza un recorrido DFS <em>post-order</em> en el árbol, ejecutando la
      * acción recibida en cada elemento del árbol.
@@ -174,6 +397,18 @@ public class ArbolBinarioOrdenado<T extends Comparable<T>>
      */
     public void dfsPostOrder(AccionVerticeArbolBinario<T> accion) {
         // Aquí va su código.
+        dfsPostOrder(accion, raiz);
+    }
+
+    private void dfsPostOrder(AccionVerticeArbolBinario<T> accion, Vertice vertice) {
+        if(vertice == null){
+            return;
+        }
+
+        dfsPostOrder(accion, vertice.izquierdo);
+
+        dfsPostOrder(accion, vertice.derecho);
+        accion.actua(vertice);
     }
 
     /**
diff --git a/src/main/java/mx/unam/ciencias/edd/ArbolRojinegro.java b/src/main/java/mx/unam/ciencias/edd/ArbolRojinegro.java
index 7460ce2..8de7aa9 100644
--- a/src/main/java/mx/unam/ciencias/edd/ArbolRojinegro.java
+++ b/src/main/java/mx/unam/ciencias/edd/ArbolRojinegro.java
@@ -32,6 +32,8 @@ public class ArbolRojinegro<T extends Comparable<T>>
          */
         public VerticeRojinegro(T elemento) {
             // Aquí va su código.
+            super(elemento);
+            color = Color.NINGUNO;
         }
 
         /**
@@ -40,8 +42,17 @@ public class ArbolRojinegro<T extends Comparable<T>>
          */
         @Override public String toString() {
             // Aquí va su código.
+            return String.format("%s{%s}", colorToString(), elemento.toString());
         }
 
+        private String colorToString() {
+            if(color == Color.ROJO){
+                return "R";
+            }else{
+                return "N";
+            }
+        }
+            
         /**
          * Compara el vértice con otro objeto. La comparación es
          * <em>recursiva</em>.
@@ -58,6 +69,7 @@ public class ArbolRojinegro<T extends Comparable<T>>
             @SuppressWarnings("unchecked")
                 VerticeRojinegro vertice = (VerticeRojinegro)objeto;
             // Aquí va su código.
+            return color == vertice.color && super.equals(objeto);
         }
     }
 
@@ -85,6 +97,7 @@ public class ArbolRojinegro<T extends Comparable<T>>
      */
     @Override protected Vertice nuevoVertice(T elemento) {
         // Aquí va su código.
+        return new VerticeRojinegro(elemento);
     }
 
     /**
@@ -96,6 +109,11 @@ public class ArbolRojinegro<T extends Comparable<T>>
      */
     public Color getColor(VerticeArbolBinario<T> vertice) {
         // Aquí va su código.
+        return verticeRojinegro(vertice).color;
+    }
+
+    private VerticeRojinegro verticeRojinegro(VerticeArbolBinario<T> vertice) {
+        return (VerticeRojinegro)vertice;
     }
 
     /**
@@ -106,6 +124,67 @@ public class ArbolRojinegro<T extends Comparable<T>>
      */
     @Override public void agrega(T elemento) {
         // Aquí va su código.
+        super.agrega(elemento);
+        VerticeRojinegro vertice = verticeRojinegro(ultimoAgregado);
+        vertice.color = Color.ROJO;
+        rebalancearAgrega(vertice);
+    }
+
+    private Color color(VerticeRojinegro vertice) {
+        if(vertice != null){
+            return vertice.color;
+        }else{
+            return Color.NEGRO;
+        }
+    }
+
+    private boolean esIzquierdo(Vertice vertice) {
+        return vertice.padre.izquierdo == vertice;
+    }
+
+    private void rebalancearAgrega(VerticeRojinegro vertice) {
+        if(vertice.padre == null){
+            vertice.color = Color.NEGRO;
+            return;
+        }
+
+        VerticeRojinegro padre = verticeRojinegro(vertice.padre);
+
+        if(color(padre) == Color.NEGRO){
+            return;
+        }
+            
+        VerticeRojinegro abuelo = verticeRojinegro(padre.padre);
+        VerticeRojinegro tio = verticeRojinegro(esIzquierdo(padre) ? abuelo.derecho : abuelo.izquierdo);
+
+        if(color(tio) == Color.ROJO){
+            padre.color = tio.color = Color.NEGRO;
+            abuelo.color = Color.ROJO;
+            rebalancearAgrega(abuelo);
+            return;
+        }
+
+        if(esIzquierdo(vertice) && !esIzquierdo(padre)){
+            super.giraDerecha(padre);
+            VerticeRojinegro temp = vertice;
+            vertice = padre;
+            padre = temp;
+        }else if(esIzquierdo(padre) && !esIzquierdo(vertice)){
+            super.giraIzquierda(padre);
+            VerticeRojinegro temp = vertice;
+            vertice = padre;
+            padre = temp;
+        }
+
+        padre.color = Color.NEGRO;
+        abuelo.color = Color.ROJO;
+
+        if(esIzquierdo(vertice)){
+            super.giraDerecha(abuelo);
+        }else{
+            super.giraIzquierda(abuelo);
+        }
+
     }
 
     /**
@@ -116,6 +195,115 @@ public class ArbolRojinegro<T extends Comparable<T>>
      */
     @Override public void elimina(T elemento) {
         // Aquí va su código.
+        VerticeRojinegro vertice = verticeRojinegro(busca(elemento));
+
+        if (vertice == null){
+            return;
+        }
+            
+
+        elementos--;
+        if((vertice.izquierdo != null) && (vertice.derecho != null)){
+            vertice = verticeRojinegro(intercambiaEliminable(vertice));
+        }
+            
+        VerticeRojinegro hijo;
+        VerticeRojinegro fantasmon = null;
+
+        if(vertice.izquierdo == null && vertice.derecho == null){
+            fantasmon = verticeRojinegro(nuevoVertice(null));
+            fantasmon.color = Color.NEGRO;
+            fantasmon.padre = vertice;
+            vertice.izquierdo = fantasmon;
+            hijo = fantasmon;
+        }else{
+            hijo = verticeRojinegro(vertice.izquierdo != null ? vertice.izquierdo : vertice.derecho);
+        }
+        
+        eliminaVertice(vertice);
+
+        if (color(hijo) == Color.ROJO || color(vertice) == Color.ROJO){
+            hijo.color = Color.NEGRO;
+        }else{
+            rebalancearElimina(hijo);
+        }
+        
+        if (fantasmon != null){
+            eliminaVertice(fantasmon);
+        }
+            
+    }
+
+    private void rebalancearElimina(VerticeRojinegro vertice) {
+        if (vertice.padre == null){
+            return;
+        }
+
+        VerticeRojinegro padre = verticeRojinegro(vertice.padre);
+        VerticeRojinegro hermano = verticeRojinegro(esIzquierdo(vertice) ? padre.derecho : padre.izquierdo);
+
+        if(color(hermano) == Color.ROJO){
+            padre.color = Color.ROJO;
+            hermano.color = Color.NEGRO;
+
+            if(esIzquierdo(vertice)){
+                super.giraIzquierda(padre);
+            }else{
+                super.giraDerecha(padre);
+            }
+            
+            padre = verticeRojinegro(vertice.padre);
+            hermano = verticeRojinegro(esIzquierdo(vertice) ? padre.derecho : padre.izquierdo);
+        }
+
+        VerticeRojinegro hermanoIzquierdo = verticeRojinegro(hermano.izquierdo);
+        VerticeRojinegro hermanoDerecho = verticeRojinegro(hermano.derecho);
+
+        if(color(padre) == Color.NEGRO && color(hermano) == Color.NEGRO && color(hermanoIzquierdo) == Color.NEGRO && color(hermanoDerecho) == Color.NEGRO){
+            hermano.color = Color.ROJO;
+            rebalancearElimina(padre);
+            return;
+        }
+
+        if(color(hermano) == Color.NEGRO && color(hermanoIzquierdo) == Color.NEGRO && color(hermanoDerecho) == Color.NEGRO && color(padre) == Color.ROJO){
+            hermano.color = Color.ROJO;
+            padre.color = Color.NEGRO;
+            return;
+        }
+
+        if((esIzquierdo(vertice) && color(hermanoIzquierdo) == Color.ROJO && color(hermanoDerecho) == Color.NEGRO) || (!esIzquierdo(vertice) && color(hermanoIzquierdo) == Color.NEGRO && color(hermanoDerecho) == Color.ROJO)){
+            hermano.color = Color.ROJO;
+
+            if(color(hermanoIzquierdo) == Color.ROJO){
+                hermanoIzquierdo.color = Color.NEGRO;
+            }
+
+            if(color(hermanoDerecho) == Color.ROJO){
+                hermanoDerecho.color = Color.NEGRO;
+            }
+                
+            if(esIzquierdo(vertice)){
+                super.giraDerecha(hermano);
+            }else{
+                super.giraIzquierda(hermano);
+            }
+            
+            hermano = verticeRojinegro(esIzquierdo(vertice) ? padre.derecho : padre.izquierdo);
+
+            hermanoIzquierdo = verticeRojinegro(hermano.izquierdo);
+            hermanoDerecho = verticeRojinegro(hermano.derecho);
+        }
+
+        hermano.color = padre.color;
+        padre.color = Color.NEGRO;
+
+        if (esIzquierdo(vertice)) {
+            hermanoDerecho.color = Color.NEGRO;
+            super.giraIzquierda(padre);
+        } else {
+            hermanoIzquierdo.color = Color.NEGRO;
+            super.giraDerecha(padre);
+        }
     }
 
     /**
diff --git a/src/main/java/mx/unam/ciencias/edd/Arreglos.java b/src/main/java/mx/unam/ciencias/edd/Arreglos.java
index 641317c..6cce1f2 100644
--- a/src/main/java/mx/unam/ciencias/edd/Arreglos.java
+++ b/src/main/java/mx/unam/ciencias/edd/Arreglos.java
@@ -1,81 +1,150 @@
-package mx.unam.ciencias.edd;
-
-import java.util.Comparator;
-
-/**
- * Clase para ordenar y buscar arreglos genéricos.
- */
-public class Arreglos {
-
-    /* Constructor privado para evitar instanciación. */
-    private Arreglos() {}
-
-    /**
-     * Ordena el arreglo recibido usando QickSort.
-     * @param <T> tipo del que puede ser el arreglo.
-     * @param arreglo el arreglo a ordenar.
-     * @param comparador el comparador para ordenar el arreglo.
-     */
-    public static <T> void
-    quickSort(T[] arreglo, Comparator<T> comparador) {
-        // Aquí va su código.
-    }
-
-    /**
-     * Ordena el arreglo recibido usando QickSort.
-     * @param <T> tipo del que puede ser el arreglo.
-     * @param arreglo un arreglo cuyos elementos son comparables.
-     */
-    public static <T extends Comparable<T>> void
-    quickSort(T[] arreglo) {
-        quickSort(arreglo, (a, b) -> a.compareTo(b));
-    }
-
-    /**
-     * Ordena el arreglo recibido usando SelectionSort.
-     * @param <T> tipo del que puede ser el arreglo.
-     * @param arreglo el arreglo a ordenar.
-     * @param comparador el comparador para ordernar el arreglo.
-     */
-    public static <T> void
-    selectionSort(T[] arreglo, Comparator<T> comparador) {
-        // Aquí va su código.
-    }
-
-    /**
-     * Ordena el arreglo recibido usando SelectionSort.
-     * @param <T> tipo del que puede ser el arreglo.
-     * @param arreglo un arreglo cuyos elementos son comparables.
-     */
-    public static <T extends Comparable<T>> void
-    selectionSort(T[] arreglo) {
-        selectionSort(arreglo, (a, b) -> a.compareTo(b));
-    }
-
-    /**
-     * Hace una búsqueda binaria del elemento en el arreglo. Regresa el índice
-     * del elemento en el arreglo, o -1 si no se encuentra.
-     * @param <T> tipo del que puede ser el arreglo.
-     * @param arreglo el arreglo dónde buscar.
-     * @param elemento el elemento a buscar.
-     * @param comparador el comparador para hacer la búsqueda.
-     * @return el índice del elemento en el arreglo, o -1 si no se encuentra.
-     */
-    public static <T> int
-    busquedaBinaria(T[] arreglo, T elemento, Comparator<T> comparador) {
-        // Aquí va su código.
-    }
-
-    /**
-     * Hace una búsqueda binaria del elemento en el arreglo. Regresa el índice
-     * del elemento en el arreglo, o -1 si no se encuentra.
-     * @param <T> tipo del que puede ser el arreglo.
-     * @param arreglo un arreglo cuyos elementos son comparables.
-     * @param elemento el elemento a buscar.
-     * @return el índice del elemento en el arreglo, o -1 si no se encuentra.
-     */
-    public static <T extends Comparable<T>> int
-    busquedaBinaria(T[] arreglo, T elemento) {
-        return busquedaBinaria(arreglo, elemento, (a, b) -> a.compareTo(b));
-    }
-}
+package mx.unam.ciencias.edd;
+
+import java.util.Comparator;
+
+/**
+ * Clase para ordenar y buscar arreglos genéricos.
+ */
+public class Arreglos {
+
+    /* Constructor privado para evitar instanciación. */
+    private Arreglos() {}
+
+    /**
+     * Ordena el arreglo recibido usando QickSort.
+     * @param <T> tipo del que puede ser el arreglo.
+     * @param arreglo el arreglo a ordenar.
+     * @param comparador el comparador para ordenar el arreglo.
+     */
+    public static <T> void
+    quickSort(T[] arreglo, Comparator<T> comparador) {
+        // Aquí va su código.
+        quickSort(arreglo, comparador, 0, arreglo.length-1);
+    }
+
+    private static <T> void
+    quickSort(T[] arreglo, Comparator<T> comparador, int a, int b) {
+        if(b <= a){
+            return;
+        }
+            
+        int izq = a + 1;
+        int der = b;
+        int result;
+
+        while (izq < der){
+            if((result = comparador.compare(arreglo[izq], arreglo[a])) > 0 && comparador.compare(arreglo[der], arreglo[a]) <= 0){
+                int tempA = izq++;
+                int tempB = der--;
+                T temp = arreglo[tempA];
+                arreglo[tempA] = arreglo[tempB];
+                arreglo[tempB] = temp;
+                }else if(result <= 0){
+                    izq++;
+                }else{
+                    der--;     
+            }
+        }
+        
+        if (comparador.compare(arreglo[izq], arreglo[a]) > 0){
+            izq--;
+        }
+            
+        T temp = arreglo[a];
+        arreglo[a] = arreglo[izq];
+        arreglo[izq] = temp;
+        
+        quickSort(arreglo, comparador, a, izq-1);
+        quickSort(arreglo, comparador, izq+1, b);
+    }
+
+    /**
+     * Ordena el arreglo recibido usando QickSort.
+     * @param <T> tipo del que puede ser el arreglo.
+     * @param arreglo un arreglo cuyos elementos son comparables.
+     */
+    public static <T extends Comparable<T>> void
+    quickSort(T[] arreglo) {
+        quickSort(arreglo, (a, b) -> a.compareTo(b));
+    }
+
+    /**
+     * Ordena el arreglo recibido usando SelectionSort.
+     * @param <T> tipo del que puede ser el arreglo.
+     * @param arreglo el arreglo a ordenar.
+     * @param comparador el comparador para ordernar el arreglo.
+     */
+    public static <T> void
+    selectionSort(T[] arreglo, Comparator<T> comparador) {
+        // Aquí va su código.
+        for(int i = 0; i < arreglo.length; i++){
+            int min = i;
+            for(int j = i + 1; j < arreglo.length; j++){
+                if(comparador.compare(arreglo[j], arreglo[min]) < 0){
+                    min = j;
+                }      
+            
+            }
+
+            T temp = arreglo[i];
+            arreglo[i] = arreglo[min];
+            arreglo[min] = temp;
+            
+        }
+    }
+
+    /**
+     * Ordena el arreglo recibido usando SelectionSort.
+     * @param <T> tipo del que puede ser el arreglo.
+     * @param arreglo un arreglo cuyos elementos son comparables.
+     */
+    public static <T extends Comparable<T>> void
+    selectionSort(T[] arreglo) {
+        selectionSort(arreglo, (a, b) -> a.compareTo(b));
+    }
+
+    /**
+     * Hace una búsqueda binaria del elemento en el arreglo. Regresa el índice
+     * del elemento en el arreglo, o -1 si no se encuentra.
+     * @param <T> tipo del que puede ser el arreglo.
+     * @param arreglo el arreglo dónde buscar.
+     * @param elemento el elemento a buscar.
+     * @param comparador el comparador para hacer la búsqueda.
+     * @return el índice del elemento en el arreglo, o -1 si no se encuentra.
+     */
+    public static <T> int
+    busquedaBinaria(T[] arreglo, T elemento, Comparator<T> comparador) {
+        // Aquí va su código.
+        int min = 0;
+	    int max = arreglo.length-1;
+	    int metallica;
+
+	    while(min < max+1) {
+		    metallica = min + (( max - min ) / 2);
+
+		    if(comparador.compare(arreglo[metallica], elemento) == 0 ){
+                return metallica;
+            }			
+	 	    if(comparador.compare(elemento, arreglo[metallica]) < 0 ){
+			    max = metallica-1;
+		    }else{
+			    min = metallica+1;
+		    }
+	    }
+
+	    return -1;
+    }
+
+    /**
+     * Hace una búsqueda binaria del elemento en el arreglo. Regresa el índice
+     * del elemento en el arreglo, o -1 si no se encuentra.
+     * @param <T> tipo del que puede ser el arreglo.
+     * @param arreglo un arreglo cuyos elementos son comparables.
+     * @param elemento el elemento a buscar.
+     * @return el índice del elemento en el arreglo, o -1 si no se encuentra.
+     */
+    public static <T extends Comparable<T>> int
+    busquedaBinaria(T[] arreglo, T elemento) {
+        return busquedaBinaria(arreglo, elemento, (a, b) -> a.compareTo(b));
+    }
+}
diff --git a/src/main/java/mx/unam/ciencias/edd/Cola.java b/src/main/java/mx/unam/ciencias/edd/Cola.java
index 8ab59f9..862e6f7 100644
--- a/src/main/java/mx/unam/ciencias/edd/Cola.java
+++ b/src/main/java/mx/unam/ciencias/edd/Cola.java
@@ -1,25 +1,49 @@
-package mx.unam.ciencias.edd;
-
-/**
- * Clase para colas genéricas.
- */
-public class Cola<T> extends MeteSaca<T> {
-
-    /**
-     * Regresa una representación en cadena de la cola.
-     * @return una representación en cadena de la cola.
-     */
-    @Override public String toString() {
-        // Aquí va su código.
-    }
-
-    /**
-     * Agrega un elemento al final de la cola.
-     * @param elemento el elemento a agregar.
-     * @throws IllegalArgumentException si <code>elemento</code> es
-     *         <code>null</code>.
-     */
-    @Override public void mete(T elemento) {
-        // Aquí va su código.
-    }
-}
+package mx.unam.ciencias.edd;
+
+/**
+ * Clase para colas genéricas.
+ */
+public class Cola<T> extends MeteSaca<T> {
+
+    /**
+     * Regresa una representación en cadena de la cola.
+     * @return una representación en cadena de la cola.
+     */
+    @Override public String toString() {
+        // Aquí va su código.
+        if(esVacia()){
+            return "";
+        }
+		
+        String colaDeLasTortillas = "";
+        Nodo tortilla = cabeza;
+
+        while(tortilla != null){
+            colaDeLasTortillas += tortilla.elemento + "," ;
+            tortilla = tortilla.siguiente;
+        }
+
+        return colaDeLasTortillas;
+    }
+
+    /**
+     * Agrega un elemento al final de la cola.
+     * @param elemento el elemento a agregar.
+     * @throws IllegalArgumentException si <code>elemento</code> es
+     *         <code>null</code>.
+     */
+    @Override public void mete(T elemento) {
+        // Aquí va su código.
+        if(elemento == null){
+            throw new IllegalArgumentException();
+        }
+
+        Nodo d = new Nodo(elemento);
+        if(cabeza == null){
+            cabeza = rabo = d;
+        }else{           
+            rabo.siguiente = d;
+            rabo = rabo.siguiente;
+            }
+    }
+}
diff --git a/src/main/java/mx/unam/ciencias/edd/Diccionario.java b/src/main/java/mx/unam/ciencias/edd/Diccionario.java
index 4d1ff0b..295ede3 100644
--- a/src/main/java/mx/unam/ciencias/edd/Diccionario.java
+++ b/src/main/java/mx/unam/ciencias/edd/Diccionario.java
@@ -22,6 +22,8 @@ public class Diccionario<K, V> implements Iterable<V> {
         /* Construye una nueva entrada. */
         public Entrada(K llave, V valor) {
             // Aquí va su código.
+            this.llave = llave;
+            this.valor = valor;
         }
     }
 
@@ -37,21 +39,49 @@ public class Diccionario<K, V> implements Iterable<V> {
          * diccionario. */
         public Iterador() {
             // Aquí va su código.
+            indice = -1;
+            mueveIterador();
         }
 
         /* Nos dice si hay una siguiente entrada. */
         public boolean hasNext() {
             // Aquí va su código.
+            if(iterador == null){
+                return false;
+            }else{
+                return true;
+            }
         }
 
         /* Regresa la siguiente entrada. */
         public Entrada siguiente() {
             // Aquí va su código.
+            if(iterador == null){
+                throw new NoSuchElementException();
+            }
+
+            Entrada entradaSig = iterador.next();
+
+            if(!iterador.hasNext()){
+                mueveIterador();
+            }
+
+            return entradaSig;
+                
         }
 
         /* Mueve el iterador a la siguiente entrada válida. */
         private void mueveIterador() {
             // Aquí va su código.
+            while(++indice < entradas.length){
+                if(entradas[indice] != null){
+                    iterador = entradas[indice].iterator();
+                    return;
+                }
+            }
+                
+            iterador = null;
+    
         }
     }
 
@@ -62,6 +92,7 @@ public class Diccionario<K, V> implements Iterable<V> {
         /* Regresa el siguiente elemento. */
         @Override public K next() {
             // Aquí va su código.
+            return siguiente().llave;
         }
     }
 
@@ -72,6 +103,7 @@ public class Diccionario<K, V> implements Iterable<V> {
         /* Regresa el siguiente elemento. */
         @Override public V next() {
             // Aquí va su código.
+            return siguiente().valor;
         }
     }
 
@@ -130,6 +162,15 @@ public class Diccionario<K, V> implements Iterable<V> {
      */
     public Diccionario(int capacidad, Dispersor<K> dispersor) {
         // Aquí va su código.
+        this.dispersor = dispersor;
+        capacidad = capacidad < MINIMA_CAPACIDAD ? MINIMA_CAPACIDAD : capacidad;
+        capacidad = potenciaDeDosMayorOIgualA(capacidad * 2);
+        entradas = nuevoArreglo(capacidad);
+    }
+
+    private int potenciaDeDosMayorOIgualA(int numerito) {
+        int x = (int) Math.ceil(Math.log(numerito) / Math.log(2));
+        return (int) Math.pow(2, x);
     }
 
     /**
@@ -142,6 +183,70 @@ public class Diccionario<K, V> implements Iterable<V> {
      */
     public void agrega(K llave, V valor) {
         // Aquí va su código.
+        if(llave == null || valor == null){
+            throw new IllegalArgumentException();
+        }
+
+        int indiceLlave = getmascaraIndice(llave);
+        Entrada entrada = new Entrada(llave, valor);
+
+        if(entradas[indiceLlave] == null){
+            entradas[indiceLlave] = new Lista<Entrada>();
+        }
+            
+        Entrada colision = buscadorLista(indiceLlave, llave);
+
+        if(colision == null){
+            entradas[indiceLlave].agrega(entrada);
+            elementos++;
+        }else{
+            colision.valor = valor;
+        }
+            
+
+        if(carga() >= MAXIMA_CARGA){
+            reordena();
+        }
+            
+    }
+
+    private int getmascaraIndice(K llave) {
+        return dispersor.dispersa(llave) & (entradas.length - 1);
+    }
+
+    private Entrada buscadorLista(int indice, K llave) {
+        if(entradas[indice] == null){
+            return null;
+        }
+            
+        for(Entrada entrada : entradas[indice]){
+            if(entrada.llave.equals(llave)){
+                return entrada;
+            }
+        }
+            
+        return null;
+
+    }
+
+    private void reordena() {
+
+        Lista<Entrada>[] nuevasEntradas = nuevoArreglo(entradas.length * 2);
+        Iterador iterador = new Iterador();
+
+        while(iterador.hasNext()){
+            Entrada entrada = iterador.siguiente();
+            int indiceLlave = dispersor.dispersa(entrada.llave) & (nuevasEntradas.length - 1);
+
+            if(nuevasEntradas[indiceLlave] == null){
+                nuevasEntradas[indiceLlave] = new Lista<Entrada>();
+            }
+                
+            nuevasEntradas[indiceLlave].agrega(entrada);
+
+        }
+
+        entradas = nuevasEntradas;
     }
 
     /**
@@ -153,6 +258,19 @@ public class Diccionario<K, V> implements Iterable<V> {
      */
     public V get(K llave) {
         // Aquí va su código.
+        if(llave == null){
+            throw new IllegalArgumentException();
+        }
+
+        int indiceLlave = getmascaraIndice(llave);
+        Entrada entrada = buscadorLista(indiceLlave, llave);
+
+        if(entrada == null){
+            throw new NoSuchElementException();
+        }
+
+        return entrada.valor;
+
     }
 
     /**
@@ -163,6 +281,15 @@ public class Diccionario<K, V> implements Iterable<V> {
      */
     public boolean contiene(K llave) {
         // Aquí va su código.
+        if(llave == null){
+            return false;
+        }
+
+        Entrada entrada = buscadorLista(getmascaraIndice(llave), llave);
+
+
+        return entrada != null;
+        
     }
 
     /**
@@ -174,6 +301,25 @@ public class Diccionario<K, V> implements Iterable<V> {
      */
     public void elimina(K llave) {
         // Aquí va su código.
+        if(llave == null){
+            throw new IllegalArgumentException();
+        }
+
+        int indiceLlave = getmascaraIndice(llave);
+        Entrada entrada = buscadorLista(indiceLlave, llave);
+
+        if(entrada == null){
+            throw new NoSuchElementException();
+        }
+            
+        entradas[indiceLlave].elimina(entrada);
+
+        if(entradas[indiceLlave].getLongitud() == 0){
+            entradas[indiceLlave] = null;
+        }
+
+        elementos--;
+
     }
 
     /**
@@ -182,6 +328,16 @@ public class Diccionario<K, V> implements Iterable<V> {
      */
     public int colisiones() {
         // Aquí va su código.
+        int total = 0;
+
+        for(Lista<Entrada> lista : entradas){
+            if(lista != null){
+                total += lista.getLongitud();
+            }
+        }
+            
+        return total == 0 ? total : total - 1;
+
     }
 
     /**
@@ -191,6 +347,16 @@ public class Diccionario<K, V> implements Iterable<V> {
      */
     public int colisionMaxima() {
         // Aquí va su código.
+        int maximo = 0;
+
+        for(Lista<Entrada> lista : entradas){
+            if(lista != null && lista.getLongitud() > maximo){
+                maximo = lista.getLongitud();
+            }
+        }
+            
+        return maximo - 1;
+
     }
 
     /**
@@ -199,6 +365,7 @@ public class Diccionario<K, V> implements Iterable<V> {
      */
     public double carga() {
         // Aquí va su código.
+        return Double.valueOf(elementos) / entradas.length;
     }
 
     /**
@@ -207,6 +374,7 @@ public class Diccionario<K, V> implements Iterable<V> {
      */
     public int getElementos() {
         // Aquí va su código.
+        return elementos;
     }
 
     /**
@@ -216,6 +384,7 @@ public class Diccionario<K, V> implements Iterable<V> {
      */
     public boolean esVacia() {
         // Aquí va su código.
+        return elementos == 0;
     }
 
     /**
@@ -223,6 +392,8 @@ public class Diccionario<K, V> implements Iterable<V> {
      */
     public void limpia() {
         // Aquí va su código.
+        elementos = 0;
+        entradas = nuevoArreglo(entradas.length);
     }
 
     /**
@@ -231,6 +402,19 @@ public class Diccionario<K, V> implements Iterable<V> {
      */
     @Override public String toString() {
         // Aquí va su código.
+        if(elementos == 0){
+            return "{}";
+        }
+
+        String texto = "{ ";
+        Iterador iterador = new Iterador();
+
+        while(iterador.hasNext()){
+            Entrada entrada = iterador.siguiente();
+            texto += String.format("'%s': '%s', ", entrada.llave, entrada.valor);
+        }
+
+        return texto + "}";
     }
 
     /**
@@ -246,6 +430,24 @@ public class Diccionario<K, V> implements Iterable<V> {
         @SuppressWarnings("unchecked") Diccionario<K, V> d =
             (Diccionario<K, V>)o;
         // Aquí va su código.
+        if(d.elementos != elementos){
+            return false;
+        }
+            
+        Iterador iterador = new Iterador();
+
+        while(iterador.hasNext()){
+            Entrada entrada = iterador.siguiente();
+
+            if(!d.contiene(entrada.llave) || !d.get(entrada.llave).equals(entrada.valor)){
+                return false;
+            }
+                
+        }
+
+        return true;
+
+        
     }
 
     /**
diff --git a/src/main/java/mx/unam/ciencias/edd/Dispersores.java b/src/main/java/mx/unam/ciencias/edd/Dispersores.java
index 0e35435..6fe3198 100644
--- a/src/main/java/mx/unam/ciencias/edd/Dispersores.java
+++ b/src/main/java/mx/unam/ciencias/edd/Dispersores.java
@@ -15,6 +15,30 @@ public class Dispersores {
      */
     public static int dispersaXOR(byte[] llave) {
         // Aquí va su código.
+        int lugar = 0;
+        int result = 0;
+        
+
+        while(lugar < llave.length){
+            result ^= mezcla(regresaEntero(llave, lugar++), regresaEntero(llave, lugar++), regresaEntero(llave, lugar++), regresaEntero(llave, lugar++));
+        }
+
+        return result;
+
+    }
+
+    private static int mezcla(int a, int b, int c, int d) {
+        return (a << 24) | (b << 16) | (c << 8)  | d;
+
+    }
+
+    private static int regresaEntero(byte[] llave, int lugar) {
+        if(lugar < llave.length){
+            return (0xFF & llave[lugar]);
+        }
+
+        return 0;
+
     }
 
     /**
@@ -24,6 +48,60 @@ public class Dispersores {
      */
     public static int dispersaBJ(byte[] llave) {
         // Aquí va su código.
+        int a = 0x9E3779B9;
+        int b = 0x9E3779B9;
+        int c = 0xFFFFFFFF;
+
+        int lugar = 0;
+        boolean maquinaEncendida = true;
+
+        while(maquinaEncendida){
+            a += mezcla(regresaEntero(llave, lugar+3), regresaEntero(llave, lugar+2), regresaEntero(llave, lugar+1), regresaEntero(llave, lugar));
+            lugar += 4;
+
+            b += mezcla(regresaEntero(llave, lugar+3), regresaEntero(llave, lugar+2), regresaEntero(llave, lugar+1), regresaEntero(llave, lugar));
+            lugar += 4;
+
+            if(llave.length - lugar >= 4){
+                c += mezcla(regresaEntero(llave, lugar+3), regresaEntero(llave, lugar+2), regresaEntero(llave, lugar+1), regresaEntero(llave, lugar));
+            }else{
+                maquinaEncendida = false;
+                c += llave.length;
+                c += mezcla(regresaEntero(llave, lugar+2), regresaEntero(llave, lugar+1), regresaEntero(llave, lugar), 0);
+            }
+
+            lugar += 4;
+
+            a -= b + c;
+            a ^= (c >>> 13);
+
+            b -= c + a;
+            b ^= (a << 8);
+
+            c -= a + b;
+            c ^= (b >>> 13);
+
+            a -= b + c;
+            a ^= (c >>> 12);
+
+            b -= c + a;
+            b ^= (a << 16);
+
+            c -= a + b;
+            c ^= (b >>> 5);
+
+            a -= b + c;
+            a ^= (c >>> 3);
+
+            b -= c + a;
+            b ^= (a << 10);
+
+            c -= a + b;
+            c ^= (b >>> 15);
+        }
+
+        return c;
+
     }
 
     /**
@@ -33,5 +111,13 @@ public class Dispersores {
      */
     public static int dispersaDJB(byte[] llave) {
         // Aquí va su código.
+        int h = 5381;
+        
+        for(int i = 0; i < llave.length; i++){
+            h += (h << 5) + regresaEntero(llave, i);
+        }
+        
+        return h;
+        
     }
 }
diff --git a/src/main/java/mx/unam/ciencias/edd/Grafica.java b/src/main/java/mx/unam/ciencias/edd/Grafica.java
index 27239d9..777b2ac 100644
--- a/src/main/java/mx/unam/ciencias/edd/Grafica.java
+++ b/src/main/java/mx/unam/ciencias/edd/Grafica.java
@@ -18,16 +18,19 @@ public class Grafica<T> implements Coleccion<T> {
         /* Construye un nuevo iterador, auxiliándose de la lista de vértices. */
         public Iterador() {
             // Aquí va su código.
+            iterador = vertices.iterator();
         }
 
         /* Nos dice si hay un siguiente elemento. */
         @Override public boolean hasNext() {
             // Aquí va su código.
+            return iterador.hasNext();
         }
 
         /* Regresa el siguiente elemento. */
         @Override public T next() {
             // Aquí va su código.
+            return iterador.next().elemento;
         }
     }
 
@@ -49,41 +52,51 @@ public class Grafica<T> implements Coleccion<T> {
         /* Crea un nuevo vértice a partir de un elemento. */
         public Vertice(T elemento) {
             // Aquí va su código.
+            this.elemento = elemento;
+            color = Color.NINGUNO;
+            vecinos = new Lista<>();
         }
 
         /* Regresa el elemento del vértice. */
         @Override public T get() {
             // Aquí va su código.
+            return elemento;
         }
 
         /* Regresa el grado del vértice. */
         @Override public int getGrado() {
             // Aquí va su código.
+            return vecinos.getLongitud();
         }
 
         /* Regresa el color del vértice. */
         @Override public Color getColor() {
             // Aquí va su código.
+            return color;
         }
 
         /* Regresa un iterable para los vecinos. */
         @Override public Iterable<? extends VerticeGrafica<T>> vecinos() {
             // Aquí va su código.
+            return vecinos;
         }
 
         /* Define el índice del vértice. */
         @Override public void setIndice(int indice) {
             // Aquí va su código.
+            this.indice = indice;
         }
 
         /* Regresa el índice del vértice. */
         @Override public int getIndice() {
             // Aquí va su código.
+            return indice;
         }
 
         /* Compara dos vértices por distancia. */
         @Override public int compareTo(Vertice vertice) {
             // Aquí va su código.
+            return Double.compare(distancia, vertice.distancia);
         }
     }
 
@@ -99,26 +112,32 @@ public class Grafica<T> implements Coleccion<T> {
          * peso especificado. */
         public Vecino(Vertice vecino, double peso) {
             // Aquí va su código.
+            this.vecino = vecino;
+            this.peso = peso;
         }
 
         /* Regresa el elemento del vecino. */
         @Override public T get() {
             // Aquí va su código.
+            return vecino.elemento;
         }
 
         /* Regresa el grado del vecino. */
         @Override public int getGrado() {
             // Aquí va su código.
+            return vecino.getGrado();
         }
 
         /* Regresa el color del vecino. */
         @Override public Color getColor() {
             // Aquí va su código.
+            return vecino.color;
         }
 
         /* Regresa un iterable para los vecinos del vecino. */
         @Override public Iterable<? extends VerticeGrafica<T>> vecinos() {
             // Aquí va su código.
+            return vecino.vecinos;
         }
     }
 
@@ -140,6 +159,7 @@ public class Grafica<T> implements Coleccion<T> {
      */
     public Grafica() {
         // Aquí va su código.
+        vertices = new Lista<>();
     }
 
     /**
@@ -149,6 +169,7 @@ public class Grafica<T> implements Coleccion<T> {
      */
     @Override public int getElementos() {
         // Aquí va su código.
+        return vertices.getElementos();
     }
 
     /**
@@ -157,6 +178,7 @@ public class Grafica<T> implements Coleccion<T> {
      */
     public int getAristas() {
         // Aquí va su código.
+        return aristas;
     }
 
     /**
@@ -167,6 +189,12 @@ public class Grafica<T> implements Coleccion<T> {
      */
     @Override public void agrega(T elemento) {
         // Aquí va su código.
+        if(elemento == null || contiene(elemento)){
+            throw new IllegalArgumentException();
+        }
+        
+        Vertice vertice = new Vertice(elemento);
+        vertices.agrega(vertice);
     }
 
     /**
@@ -180,6 +208,7 @@ public class Grafica<T> implements Coleccion<T> {
      */
     public void conecta(T a, T b) {
         // Aquí va su código.
+        conecta(a, b, 1);
     }
 
     /**
@@ -194,6 +223,22 @@ public class Grafica<T> implements Coleccion<T> {
      */
     public void conecta(T a, T b, double peso) {
         // Aquí va su código.
+        if(a.equals(b) || peso <= 0){
+            throw new IllegalArgumentException();
+        }
+
+        Vertice verticePrimero = (Vertice) vertice(a);
+        Vertice verticeSegundo = (Vertice) vertice(b);
+
+        if(sonVecinos(verticePrimero.elemento, verticeSegundo.elemento)){
+            throw new IllegalArgumentException();
+        }
+
+        verticePrimero.vecinos.agrega(new Vecino(verticeSegundo, peso));
+        verticeSegundo.vecinos.agrega(new Vecino(verticePrimero, peso));
+
+        aristas++;
+
     }
 
     /**
@@ -206,6 +251,25 @@ public class Grafica<T> implements Coleccion<T> {
      */
     public void desconecta(T a, T b) {
         // Aquí va su código.
+        Vertice verticePrimero = (Vertice) vertice(a);
+        Vertice verticeSegundo = (Vertice) vertice(b);
+
+        if(!sonVecinos(verticePrimero.elemento, verticeSegundo.elemento)){
+            throw new IllegalArgumentException();
+        }
+
+	    for (Vecino vecino : verticePrimero.vecinos)
+            if (vecino.vecino.elemento.equals(verticeSegundo.elemento)) {
+                verticePrimero.vecinos.elimina(vecino);
+            }
+
+
+        for (Vecino vecino : verticeSegundo.vecinos)
+            if (vecino.vecino.elemento.equals(verticePrimero.elemento)) {
+                verticeSegundo.vecinos.elimina(vecino);
+            }
+
+        aristas--;
     }
 
     /**
@@ -215,6 +279,13 @@ public class Grafica<T> implements Coleccion<T> {
      */
     @Override public boolean contiene(T elemento) {
         // Aquí va su código.
+        for(Vertice vertice : vertices){
+            if(vertice.elemento.equals(elemento)){
+                return true;
+            }
+        }
+            
+        return false;
     }
 
     /**
@@ -226,6 +297,13 @@ public class Grafica<T> implements Coleccion<T> {
      */
     @Override public void elimina(T elemento) {
         // Aquí va su código.
+
+        Vertice vertice = (Vertice) vertice(elemento);
+
+        for (Vecino vecino : vertice.vecinos)
+            desconecta(vertice.elemento, vecino.vecino.elemento);
+
+        vertices.elimina(vertice);
     }
 
     /**
@@ -238,6 +316,14 @@ public class Grafica<T> implements Coleccion<T> {
      */
     public boolean sonVecinos(T a, T b) {
         // Aquí va su código.
+        Vertice verticePrimero = (Vertice) vertice(a);
+        Vertice verticeSegundo = (Vertice) vertice(b);
+
+	    for (Vecino vecino : verticePrimero.vecinos)
+            if (vecino.vecino.elemento.equals(verticeSegundo.elemento))
+                return true;
+
+        return false;
     }
 
     /**
@@ -252,6 +338,21 @@ public class Grafica<T> implements Coleccion<T> {
      */
     public double getPeso(T a, T b) {
         // Aquí va su código.
+        if(!contiene(a)){
+            throw new NoSuchElementException();
+        }
+            
+
+        Vertice vertice = (Vertice) vertice(b);
+
+        for (Vecino vecino : vertice.vecinos){
+            if (vecino.vecino.elemento.equals(a)){
+                return vecino.peso;
+            }
+        }
+            
+        throw new IllegalArgumentException();
+
     }
 
     /**
@@ -267,6 +368,34 @@ public class Grafica<T> implements Coleccion<T> {
      */
     public void setPeso(T a, T b, double peso) {
         // Aquí va su código.
+        Vertice verticePrimero = (Vertice) vertice(a);
+        Vertice verticeSegundo = (Vertice) vertice(b);
+
+        if(peso <= 0){
+            throw new IllegalArgumentException();
+        }
+
+        if(!sonVecinos(verticePrimero.elemento, verticeSegundo.elemento)){
+            throw new IllegalArgumentException();
+        }
+            
+
+        for(Vecino vecino : verticePrimero.vecinos){
+            if(vecino.vecino.equals(verticeSegundo)){
+                vecino.peso = peso;
+                break;
+            }
+        }
+            
+
+        for(Vecino vecino : verticeSegundo.vecinos){
+            if(vecino.vecino.equals(verticePrimero)){
+                vecino.peso = peso;
+                break;
+            }
+        }
+            
+            
     }
 
     /**
@@ -277,6 +406,14 @@ public class Grafica<T> implements Coleccion<T> {
      */
     public VerticeGrafica<T> vertice(T elemento) {
         // Aquí va su código.
+        for(Vertice vertice : vertices){
+            if(vertice.elemento.equals(elemento)){
+                return vertice;
+            }
+            
+        }
+            
+        throw new NoSuchElementException();
     }
 
     /**
@@ -287,6 +424,20 @@ public class Grafica<T> implements Coleccion<T> {
      */
     public void setColor(VerticeGrafica<T> vertice, Color color) {
         // Aquí va su código.
+        if (vertice == null || (vertice.getClass() != Vertice.class && vertice.getClass() != Vecino.class)){
+            throw new IllegalArgumentException();
+        }
+            
+
+        if(vertice.getClass() == Vertice.class){
+            Vertice verticeAux = (Vertice) vertice;
+            verticeAux.color = color;
+        }
+
+        if(vertice.getClass() == Vecino.class){
+            Vecino verticeAux = (Vecino) vertice;
+            verticeAux.vecino.color = color;
+        }
     }
 
     /**
@@ -296,6 +447,38 @@ public class Grafica<T> implements Coleccion<T> {
      */
     public boolean esConexa() {
         // Aquí va su código.
+        recorre(vertices.getPrimero().elemento, e -> {}, new Cola<Vertice>());
+
+        for (Vertice v : vertices){
+            if (v.color == Color.ROJO){
+                return false;
+            }
+        }
+
+        return true;
+
+    }
+
+    private void recorre(T elemento, AccionVerticeGrafica<T> accion, MeteSaca<Vertice> estructura) {
+        Vertice vertice = (Vertice) vertice(elemento);
+
+        paraCadaVertice((v) -> setColor(v, Color.ROJO));
+
+        vertice.color = Color.NEGRO;
+        estructura.mete(vertice);
+
+        while(!estructura.esVacia()){
+            vertice = estructura.saca();
+            accion.actua(vertice);
+
+            for(Vecino vecino : vertice.vecinos){
+                if(vecino.vecino.color == Color.ROJO){
+                    vecino.vecino.color = Color.NEGRO;
+                    estructura.mete(vecino.vecino);
+                }
+            }
+                
+        }
     }
 
     /**
@@ -305,6 +488,11 @@ public class Grafica<T> implements Coleccion<T> {
      */
     public void paraCadaVertice(AccionVerticeGrafica<T> accion) {
         // Aquí va su código.
+        for(Vertice vertice : vertices){
+            accion.actua(vertice);
+        }
+
+
     }
 
     /**
@@ -319,8 +507,12 @@ public class Grafica<T> implements Coleccion<T> {
      */
     public void bfs(T elemento, AccionVerticeGrafica<T> accion) {
         // Aquí va su código.
+        recorre(elemento, accion, new Cola<Vertice>());
+        paraCadaVertice((v) -> setColor(v, Color.NINGUNO));
+
     }
 
+
     /**
      * Realiza la acción recibida en todos los vértices de la gráfica, en el
      * orden determinado por DFS, comenzando por el vértice correspondiente al
@@ -333,6 +525,9 @@ public class Grafica<T> implements Coleccion<T> {
      */
     public void dfs(T elemento, AccionVerticeGrafica<T> accion) {
         // Aquí va su código.
+        recorre(elemento, accion, new Pila<Vertice>());
+        paraCadaVertice((v) -> setColor(v, Color.NINGUNO));
+
     }
 
     /**
@@ -342,6 +537,7 @@ public class Grafica<T> implements Coleccion<T> {
      */
     @Override public boolean esVacia() {
         // Aquí va su código.
+        return vertices.esVacia();
     }
 
     /**
@@ -349,6 +545,8 @@ public class Grafica<T> implements Coleccion<T> {
      */
     @Override public void limpia() {
         // Aquí va su código.
+        vertices.limpia();
+        aristas = 0;
     }
 
     /**
@@ -357,6 +555,28 @@ public class Grafica<T> implements Coleccion<T> {
      */
     @Override public String toString() {
         // Aquí va su código.
+        String texto = "{";
+
+        for(Vertice vertice : vertices){
+            texto += String.format("%s, ", vertice.elemento.toString());
+        }
+            
+        texto += "}, {";
+        Lista<T> verticesPasados = new Lista<>();
+
+        for(Vertice vertice : vertices){
+            for(Vecino vecino : vertice.vecinos){
+                if(!verticesPasados.contiene(vecino.vecino.elemento)){
+                    texto += String.format("(%s, %s), ", vertice.elemento.toString(), vecino.vecino.elemento.toString());
+                }
+            }
+
+            verticesPasados.agrega(vertice.elemento);
+
+        }
+
+        texto += "}";
+        return texto;
     }
 
     /**
@@ -370,6 +590,42 @@ public class Grafica<T> implements Coleccion<T> {
             return false;
         @SuppressWarnings("unchecked") Grafica<T> grafica = (Grafica<T>)objeto;
         // Aquí va su código.
+        if(aristas != grafica.aristas || vertices.getLongitud() != grafica.vertices.getLongitud()){
+            return false;
+        }
+            
+        for(Vertice vertice : vertices){
+
+            if (!grafica.contiene(vertice.elemento)){
+                return false;
+            }
+                
+            Vertice vertice2 = (Vertice) grafica.vertice(vertice.elemento);
+
+            if(vertice.vecinos.getLongitud() != vertice2.vecinos.getLongitud()){
+                return false;
+            }
+
+            for(Vecino vecino1 : vertice.vecinos){
+                boolean contiene = false;
+
+                for(Vecino vecino2 : vertice2.vecinos){
+                    if(vecino1.vecino.elemento.equals(vecino2.vecino.elemento)){
+                        contiene = true;
+                        break;
+                    }
+                }
+
+                if(!contiene){
+                    return false;
+                }
+                    
+            }
+
+        }
+
+        return true;
+        
     }
 
     /**
@@ -394,6 +650,68 @@ public class Grafica<T> implements Coleccion<T> {
      */
     public Lista<VerticeGrafica<T>> trayectoriaMinima(T origen, T destino) {
         // Aquí va su código.
+        if(!contiene(origen) || !contiene(destino)){
+            throw new NoSuchElementException();
+        }
+
+        Vertice vertice = (Vertice) vertice(origen);
+
+        if(origen.equals(destino)){
+            Lista<VerticeGrafica<T>> lista = new Lista<>();
+            lista.agrega(vertice);
+            return lista;
+        }
+
+        for(Vertice v : vertices){
+            v.distancia = Double.MAX_VALUE;
+        }
+
+        vertice.distancia = 0;
+
+        Cola<Vertice> cola = new Cola<>();
+        cola.mete(vertice);
+
+        while(!cola.esVacia()){
+            vertice = cola.saca();
+
+            for(Vecino vecino : vertice.vecinos){
+                if(vecino.vecino.distancia == Double.MAX_VALUE){
+                    vecino.vecino.distancia = vertice.distancia + 1;
+                    cola.mete(vecino.vecino);
+                }
+            }
+                
+        }
+
+        return caminoDeRegreso((aux, vecino) -> vecino.vecino.distancia == aux.distancia - 1, (Vertice) vertice(destino));
+    
+    }
+
+    @SuppressWarnings("unchecked")
+    private Lista<VerticeGrafica<T>> caminoDeRegreso(BuscadorCamino buscador, Vertice destino) {
+        
+        Vertice verticeAux = destino;
+        Lista<VerticeGrafica<T>> trayectoria = new Lista<>();
+
+        if(verticeAux.distancia == Double.MAX_VALUE){
+            return new Lista<VerticeGrafica<T>>();
+        }
+
+        trayectoria.agrega(verticeAux);
+        
+        while(verticeAux.distancia != 0){
+            for(Vecino vecino : verticeAux.vecinos){
+                if(buscador.seSiguen(verticeAux, vecino)){
+                    trayectoria.agrega(vecino.vecino);
+                    verticeAux = vecino.vecino;
+                    break;
+                }
+
+            }
+        }
+
+        return trayectoria.reversa();
+
     }
 
     /**
@@ -409,5 +727,40 @@ public class Grafica<T> implements Coleccion<T> {
      */
     public Lista<VerticeGrafica<T>> dijkstra(T origen, T destino) {
         // Aquí va su código.
+        if(!contiene(origen) || !contiene(destino)){
+            throw new NoSuchElementException();
+        }
+
+        for(Vertice vertice : vertices){
+            vertice.distancia = Double.MAX_VALUE;
+        }
+
+        Vertice verticeOrigen = (Vertice) vertice(origen);
+        verticeOrigen.distancia = 0;
+
+        MonticuloDijkstra<Vertice> monticulo;
+        int n = vertices.getElementos();
+
+        if(aristas > ((n*(n - 1))/2)-n){
+            monticulo = new MonticuloArreglo<>(vertices);
+        }else{
+            monticulo = new MonticuloMinimo<>(vertices);
+        }
+            
+
+        while(!monticulo.esVacia()){
+            Vertice raiz = monticulo.elimina();
+
+            for(Vecino vecino : raiz.vecinos){
+                if(vecino.vecino.distancia > raiz.distancia + vecino.peso){
+                    vecino.vecino.distancia = raiz.distancia + vecino.peso;
+                    monticulo.reordena(vecino.vecino);
+                }
+            }
+                
+        }
+
+        return caminoDeRegreso((vertice, vecino) -> vecino.vecino.distancia + vecino.peso == vertice.distancia, (Vertice) vertice(destino));
+        
     }
 }
diff --git a/src/main/java/mx/unam/ciencias/edd/IteradorLista.java b/src/main/java/mx/unam/ciencias/edd/IteradorLista.java
index 00d3bde..618641a 100644
--- a/src/main/java/mx/unam/ciencias/edd/IteradorLista.java
+++ b/src/main/java/mx/unam/ciencias/edd/IteradorLista.java
@@ -1,42 +1,42 @@
-package mx.unam.ciencias.edd;
-
-import java.util.Iterator;
-import java.util.NoSuchElementException;
-
-/**
- * Interfaz para iteradores de lista. Un iterador de lista se puede visualizar
- * como que está siempre entre dos elementos de la lista, o antes del primero, o
- * después del último.
- */
-public interface IteradorLista<T> extends Iterator<T> {
-
-    /**
-     * Nos dice si hay un elemento anterior. El método debe regresar
-     * <code>true</code>, excepto cuando la lista esté vacía, o el iterador esté
-     * antes del primer elemento.
-     * @return <code>true</code> si el iterador tiene un elemento a su
-     *         izquierda, <code>false</code> en otro caso.
-     */
-    public boolean hasPrevious();
-
-    /**
-     * Regresa el elemento anterior al iterador, y lo mueve a la izquierda.
-     * @return el elemento anterior al iterador.
-     * @throws NoSuchElementException si el iterador no tiene elemento anterior.
-     */
-    public T previous();
-
-    /**
-     * Mueve el iterador a la izquierda del primer elemento. Después de llamar
-     * este método, el método {@link Iterator#hasNext} siempre regresa
-     * <code>true</code> si la lista no es vacía.
-     */
-    public void start();
-
-    /**
-     * Mueve el iterador a la derecha del último elemento. Después de llamar
-     * este método, el método {@link IteradorLista#hasPrevious} siempre regresa
-     * <code>true</code> si la lista no es vacía.
-     */
-    public void end();
-}
+package mx.unam.ciencias.edd;
+
+import java.util.Iterator;
+import java.util.NoSuchElementException;
+
+/**
+ * Interfaz para iteradores de lista. Un iterador de lista se puede visualizar
+ * como que está siempre entre dos elementos de la lista, o antes del primero, o
+ * después del último.
+ */
+public interface IteradorLista<T> extends Iterator<T> {
+
+    /**
+     * Nos dice si hay un elemento anterior. El método debe regresar
+     * <code>true</code>, excepto cuando la lista esté vacía, o el iterador esté
+     * antes del primer elemento.
+     * @return <code>true</code> si el iterador tiene un elemento a su
+     *         izquierda, <code>false</code> en otro caso.
+     */
+    public boolean hasPrevious();
+
+    /**
+     * Regresa el elemento anterior al iterador, y lo mueve a la izquierda.
+     * @return el elemento anterior al iterador.
+     * @throws NoSuchElementException si el iterador no tiene elemento anterior.
+     */
+    public T previous();
+
+    /**
+     * Mueve el iterador a la izquierda del primer elemento. Después de llamar
+     * este método, el método {@link Iterator#hasNext} siempre regresa
+     * <code>true</code> si la lista no es vacía.
+     */
+    public void start();
+
+    /**
+     * Mueve el iterador a la derecha del último elemento. Después de llamar
+     * este método, el método {@link IteradorLista#hasPrevious} siempre regresa
+     * <code>true</code> si la lista no es vacía.
+     */
+    public void end();
+}
diff --git a/src/main/java/mx/unam/ciencias/edd/Lista.java b/src/main/java/mx/unam/ciencias/edd/Lista.java
index ace1fe8..c52e4da 100644
--- a/src/main/java/mx/unam/ciencias/edd/Lista.java
+++ b/src/main/java/mx/unam/ciencias/edd/Lista.java
@@ -1,353 +1,665 @@
-package mx.unam.ciencias.edd;
-
-import java.util.Comparator;
-import java.util.Iterator;
-import java.util.NoSuchElementException;
-
-/**
- * <p>Clase genérica para listas doblemente ligadas.</p>
- *
- * <p>Las listas nos permiten agregar elementos al inicio o final de la lista,
- * eliminar elementos de la lista, comprobar si un elemento está o no en la
- * lista, y otras operaciones básicas.</p>
- *
- * <p>Las listas no aceptan a <code>null</code> como elemento.</p>
- *
- * @param <T> El tipo de los elementos de la lista.
- */
-public class Lista<T> implements Coleccion<T> {
-
-    /* Clase interna privada para nodos. */
-    private class Nodo {
-        /* El elemento del nodo. */
-        private T elemento;
-        /* El nodo anterior. */
-        private Nodo anterior;
-        /* El nodo siguiente. */
-        private Nodo siguiente;
-
-        /* Construye un nodo con un elemento. */
-        private Nodo(T elemento) {
-            // Aquí va su código.
-        }
-    }
-
-    /* Clase interna privada para iteradores. */
-    private class Iterador implements IteradorLista<T> {
-        /* El nodo anterior. */
-        private Nodo anterior;
-        /* El nodo siguiente. */
-        private Nodo siguiente;
-
-        /* Construye un nuevo iterador. */
-        private Iterador() {
-            // Aquí va su código.
-        }
-
-        /* Nos dice si hay un elemento siguiente. */
-        @Override public boolean hasNext() {
-            // Aquí va su código.
-        }
-
-        /* Nos da el elemento siguiente. */
-        @Override public T next() {
-            // Aquí va su código.
-        }
-
-        /* Nos dice si hay un elemento anterior. */
-        @Override public boolean hasPrevious() {
-            // Aquí va su código.
-        }
-
-        /* Nos da el elemento anterior. */
-        @Override public T previous() {
-            // Aquí va su código.
-        }
-
-        /* Mueve el iterador al inicio de la lista. */
-        @Override public void start() {
-            // Aquí va su código.
-        }
-
-        /* Mueve el iterador al final de la lista. */
-        @Override public void end() {
-            // Aquí va su código.
-        }
-    }
-
-    /* Primer elemento de la lista. */
-    private Nodo cabeza;
-    /* Último elemento de la lista. */
-    private Nodo rabo;
-    /* Número de elementos en la lista. */
-    private int longitud;
-
-    /**
-     * Regresa la longitud de la lista. El método es idéntico a {@link
-     * #getElementos}.
-     * @return la longitud de la lista, el número de elementos que contiene.
-     */
-    public int getLongitud() {
-        // Aquí va su código.
-    }
-
-    /**
-     * Regresa el número elementos en la lista. El método es idéntico a {@link
-     * #getLongitud}.
-     * @return el número elementos en la lista.
-     */
-    @Override public int getElementos() {
-        // Aquí va su código.
-    }
-
-    /**
-     * Nos dice si la lista es vacía.
-     * @return <code>true</code> si la lista es vacía, <code>false</code> en
-     *         otro caso.
-     */
-    @Override public boolean esVacia() {
-        // Aquí va su código.
-    }
-
-    /**
-     * Agrega un elemento a la lista. Si la lista no tiene elementos, el
-     * elemento a agregar será el primero y último. El método es idéntico a
-     * {@link #agregaFinal}.
-     * @param elemento el elemento a agregar.
-     * @throws IllegalArgumentException si <code>elemento</code> es
-     *         <code>null</code>.
-     */
-    @Override public void agrega(T elemento) {
-        // Aquí va su código.
-    }
-
-    /**
-     * Agrega un elemento al final de la lista. Si la lista no tiene elementos,
-     * el elemento a agregar será el primero y último.
-     * @param elemento el elemento a agregar.
-     * @throws IllegalArgumentException si <code>elemento</code> es
-     *         <code>null</code>.
-     */
-    public void agregaFinal(T elemento) {
-        // Aquí va su código.
-    }
-
-    /**
-     * Agrega un elemento al inicio de la lista. Si la lista no tiene elementos,
-     * el elemento a agregar será el primero y último.
-     * @param elemento el elemento a agregar.
-     * @throws IllegalArgumentException si <code>elemento</code> es
-     *         <code>null</code>.
-     */
-    public void agregaInicio(T elemento) {
-        // Aquí va su código.
-    }
-
-    /**
-     * Inserta un elemento en un índice explícito.
-     *
-     * Si el índice es menor o igual que cero, el elemento se agrega al inicio
-     * de la lista. Si el índice es mayor o igual que el número de elementos en
-     * la lista, el elemento se agrega al fina de la misma. En otro caso,
-     * después de mandar llamar el método, el elemento tendrá el índice que se
-     * especifica en la lista.
-     * @param i el índice dónde insertar el elemento. Si es menor que 0 el
-     *          elemento se agrega al inicio de la lista, y si es mayor o igual
-     *          que el número de elementos en la lista se agrega al final.
-     * @param elemento el elemento a insertar.
-     * @throws IllegalArgumentException si <code>elemento</code> es
-     *         <code>null</code>.
-     */
-    public void inserta(int i, T elemento) {
-        // Aquí va su código.
-    }
-
-    /**
-     * Elimina un elemento de la lista. Si el elemento no está contenido en la
-     * lista, el método no la modifica.
-     * @param elemento el elemento a eliminar.
-     */
-    @Override public void elimina(T elemento) {
-        // Aquí va su código.
-    }
-
-    /**
-     * Elimina el primer elemento de la lista y lo regresa.
-     * @return el primer elemento de la lista antes de eliminarlo.
-     * @throws NoSuchElementException si la lista es vacía.
-     */
-    public T eliminaPrimero() {
-        // Aquí va su código.
-    }
-
-    /**
-     * Elimina el último elemento de la lista y lo regresa.
-     * @return el último elemento de la lista antes de eliminarlo.
-     * @throws NoSuchElementException si la lista es vacía.
-     */
-    public T eliminaUltimo() {
-        // Aquí va su código.
-    }
-
-    /**
-     * Nos dice si un elemento está en la lista.
-     * @param elemento el elemento que queremos saber si está en la lista.
-     * @return <code>true</code> si <code>elemento</code> está en la lista,
-     *         <code>false</code> en otro caso.
-     */
-    @Override public boolean contiene(T elemento) {
-        // Aquí va su código.
-    }
-
-    /**
-     * Regresa la reversa de la lista.
-     * @return una nueva lista que es la reversa la que manda llamar el método.
-     */
-    public Lista<T> reversa() {
-        // Aquí va su código.
-    }
-
-    /**
-     * Regresa una copia de la lista. La copia tiene los mismos elementos que la
-     * lista que manda llamar el método, en el mismo orden.
-     * @return una copiad de la lista.
-     */
-    public Lista<T> copia() {
-        // Aquí va su código.
-    }
-
-    /**
-     * Limpia la lista de elementos, dejándola vacía.
-     */
-    @Override public void limpia() {
-        // Aquí va su código.
-    }
-
-    /**
-     * Regresa el primer elemento de la lista.
-     * @return el primer elemento de la lista.
-     * @throws NoSuchElementException si la lista es vacía.
-     */
-    public T getPrimero() {
-        // Aquí va su código.
-    }
-
-    /**
-     * Regresa el último elemento de la lista.
-     * @return el primer elemento de la lista.
-     * @throws NoSuchElementException si la lista es vacía.
-     */
-    public T getUltimo() {
-        // Aquí va su código.
-    }
-
-    /**
-     * Regresa el <em>i</em>-ésimo elemento de la lista.
-     * @param i el índice del elemento que queremos.
-     * @return el <em>i</em>-ésimo elemento de la lista.
-     * @throws ExcepcionIndiceInvalido si <em>i</em> es menor que cero o mayor o
-     *         igual que el número de elementos en la lista.
-     */
-    public T get(int i) {
-        // Aquí va su código.
-    }
-
-    /**
-     * Regresa el índice del elemento recibido en la lista.
-     * @param elemento el elemento del que se busca el índice.
-     * @return el índice del elemento recibido en la lista, o -1 si el elemento
-     *         no está contenido en la lista.
-     */
-    public int indiceDe(T elemento) {
-        // Aquí va su código.
-    }
-
-    /**
-     * Regresa una representación en cadena de la lista.
-     * @return una representación en cadena de la lista.
-     */
-    @Override public String toString() {
-        // Aquí va su código.
-    }
-
-    /**
-     * Nos dice si la lista es igual al objeto recibido.
-     * @param objeto el objeto con el que hay que comparar.
-     * @return <code>true</code> si la lista es igual al objeto recibido;
-     *         <code>false</code> en otro caso.
-     */
-    @Override public boolean equals(Object objeto) {
-        if (objeto == null || getClass() != objeto.getClass())
-            return false;
-        @SuppressWarnings("unchecked") Lista<T> lista = (Lista<T>)objeto;
-        // Aquí va su código.
-    }
-
-    /**
-     * Regresa un iterador para recorrer la lista en una dirección.
-     * @return un iterador para recorrer la lista en una dirección.
-     */
-    @Override public Iterator<T> iterator() {
-        return new Iterador();
-    }
-
-    /**
-     * Regresa un iterador para recorrer la lista en ambas direcciones.
-     * @return un iterador para recorrer la lista en ambas direcciones.
-     */
-    public IteradorLista<T> iteradorLista() {
-        return new Iterador();
-    }
-
-    /**
-     * Regresa una copia de la lista, pero ordenada. Para poder hacer el
-     * ordenamiento, el método necesita una instancia de {@link Comparator} para
-     * poder comparar los elementos de la lista.
-     * @param comparador el comparador que la lista usará para hacer el
-     *                   ordenamiento.
-     * @return una copia de la lista, pero ordenada.
-     */
-    public Lista<T> mergeSort(Comparator<T> comparador) {
-        // Aquí va su código.
-    }
-
-    /**
-     * Regresa una copia de la lista recibida, pero ordenada. La lista recibida
-     * tiene que contener nada más elementos que implementan la interfaz {@link
-     * Comparable}.
-     * @param <T> tipo del que puede ser la lista.
-     * @param lista la lista que se ordenará.
-     * @return una copia de la lista recibida, pero ordenada.
-     */
-    public static <T extends Comparable<T>>
-    Lista<T> mergeSort(Lista<T> lista) {
-        return lista.mergeSort((a, b) -> a.compareTo(b));
-    }
-
-    /**
-     * Busca un elemento en la lista ordenada, usando el comparador recibido. El
-     * método supone que la lista está ordenada usando el mismo comparador.
-     * @param elemento el elemento a buscar.
-     * @param comparador el comparador con el que la lista está ordenada.
-     * @return <code>true</code> si el elemento está contenido en la lista,
-     *         <code>false</code> en otro caso.
-     */
-    public boolean busquedaLineal(T elemento, Comparator<T> comparador) {
-        // Aquí va su código.
-    }
-
-    /**
-     * Busca un elemento en una lista ordenada. La lista recibida tiene que
-     * contener nada más elementos que implementan la interfaz {@link
-     * Comparable}, y se da por hecho que está ordenada.
-     * @param <T> tipo del que puede ser la lista.
-     * @param lista la lista donde se buscará.
-     * @param elemento el elemento a buscar.
-     * @return <code>true</code> si el elemento está contenido en la lista,
-     *         <code>false</code> en otro caso.
-     */
-    public static <T extends Comparable<T>>
-    boolean busquedaLineal(Lista<T> lista, T elemento) {
-        return lista.busquedaLineal(elemento, (a, b) -> a.compareTo(b));
-    }
-}
+package mx.unam.ciencias.edd;
+
+import java.util.Comparator;
+import java.util.Iterator;
+import java.util.NoSuchElementException;
+
+/**
+ * <p>Clase genérica para listas doblemente ligadas.</p>
+ *
+ * <p>Las listas nos permiten agregar elementos al inicio o final de la lista,
+ * eliminar elementos de la lista, comprobar si un elemento está o no en la
+ * lista, y otras operaciones básicas.</p>
+ *
+ * <p>Las listas no aceptan a <code>null</code> como elemento.</p>
+ *
+ * @param <T> El tipo de los elementos de la lista.
+ */
+public class Lista<T> implements Coleccion<T> {
+
+    /* Clase interna privada para nodos. */
+    private class Nodo {
+        /* El elemento del nodo. */
+        private T elemento;
+        /* El nodo anterior. */
+        private Nodo anterior;
+        /* El nodo siguiente. */
+        private Nodo siguiente;
+
+        /* Construye un nodo con un elemento. */
+        private Nodo(T elemento) {
+            // Aquí va su código.
+            this.elemento = elemento;
+        }
+    }
+
+    /* Clase interna privada para iteradores. */
+    private class Iterador implements IteradorLista<T> {
+        /* El nodo anterior. */
+        private Nodo anterior;
+        /* El nodo siguiente. */
+        private Nodo siguiente;
+
+        /* Construye un nuevo iterador. */
+        private Iterador() {
+            // Aquí va su código.
+            anterior = null;
+            siguiente = cabeza;
+        }
+
+        /* Nos dice si hay un elemento siguiente. */
+        @Override public boolean hasNext() {
+            // Aquí va su código.
+            if (siguiente == null ){
+                return false;
+            } else {
+                return true;
+            }
+        }
+
+        /* Nos da el elemento siguiente. */
+        @Override public T next() {
+            // Aquí va su código.
+            if(siguiente != null){
+                anterior = siguiente;
+                siguiente = siguiente.siguiente;
+            } else {
+                throw new NoSuchElementException();
+            }
+            return anterior.elemento;
+        }
+
+        /* Nos dice si hay un elemento anterior. */
+        @Override public boolean hasPrevious() {
+            // Aquí va su código.
+            if (anterior == null ){
+                return false;
+            } else {
+                return true;
+            }
+        }
+
+        /* Nos da el elemento anterior. */
+        @Override public T previous() {
+            // Aquí va su código.
+            if(anterior != null){
+                siguiente = anterior;
+                anterior = anterior.anterior;
+            } else {
+                throw new NoSuchElementException();
+            }
+            return siguiente.elemento;
+        }
+
+        /* Mueve el iterador al inicio de la lista. */
+        @Override public void start() {
+            // Aquí va su código.
+            siguiente = cabeza;
+            anterior = null;
+        }
+
+        /* Mueve el iterador al final de la lista. */
+        @Override public void end() {
+            // Aquí va su código.
+            siguiente = null;
+            anterior = rabo;
+        }
+    }
+
+    /* Primer elemento de la lista. */
+    private Nodo cabeza;
+    /* Último elemento de la lista. */
+    private Nodo rabo;
+    /* Número de elementos en la lista. */
+    private int longitud;
+
+    /**
+     * Regresa la longitud de la lista. El método es idéntico a {@link
+     * #getElementos}.
+     * @return la longitud de la lista, el número de elementos que contiene.
+     */
+    public int getLongitud() {
+        // Aquí va su código.
+        return longitud;
+    }
+
+    /**
+     * Regresa el número elementos en la lista. El método es idéntico a {@link
+     * #getLongitud}.
+     * @return el número elementos en la lista.
+     */
+    @Override public int getElementos() {
+        // Aquí va su código.
+        return getLongitud();
+    }
+
+    /**
+     * Nos dice si la lista es vacía.
+     * @return <code>true</code> si la lista es vacía, <code>false</code> en
+     *         otro caso.
+     */
+    @Override public boolean esVacia() {
+        // Aquí va su código.
+        if(rabo == null){
+            return true;
+        } else {
+            return false;
+        }
+    }
+
+    /**
+     * Agrega un elemento a la lista. Si la lista no tiene elementos, el
+     * elemento a agregar será el primero y último. El método es idéntico a
+     * {@link #agregaFinal}.
+     * @param elemento el elemento a agregar.
+     * @throws IllegalArgumentException si <code>elemento</code> es
+     *         <code>null</code>.
+     */
+    @Override public void agrega(T elemento) {
+        // Aquí va su código.
+        if(elemento == null){
+            throw new IllegalArgumentException();
+        } 
+
+        Nodo n = new Nodo(elemento);
+
+        if(cabeza == null){
+            cabeza = rabo = n;
+        } else {
+            rabo.siguiente = n;
+            n.anterior = rabo;
+            rabo = n;
+        }
+
+        longitud++;
+    }
+
+    /**
+     * Agrega un elemento al final de la lista. Si la lista no tiene elementos,
+     * el elemento a agregar será el primero y último.
+     * @param elemento el elemento a agregar.
+     * @throws IllegalArgumentException si <code>elemento</code> es
+     *         <code>null</code>.
+     */
+    public void agregaFinal(T elemento) {
+        // Aquí va su código.
+        agrega(elemento);
+    }
+
+    /**
+     * Agrega un elemento al inicio de la lista. Si la lista no tiene elementos,
+     * el elemento a agregar será el primero y último.
+     * @param elemento el elemento a agregar.
+     * @throws IllegalArgumentException si <code>elemento</code> es
+     *         <code>null</code>.
+     */
+    public void agregaInicio(T elemento) {
+        // Aquí va su código.
+        if(elemento == null){
+            throw new IllegalArgumentException();
+        } 
+
+        Nodo n = new Nodo(elemento);
+
+        if(cabeza == null){
+            cabeza = rabo = n;
+        } else {
+            cabeza.anterior = n;
+            n.siguiente = cabeza;
+            cabeza = n;
+        }
+
+        longitud++;
+    }
+
+    /**
+     * Inserta un elemento en un índice explícito.
+     *
+     * Si el índice es menor o igual que cero, el elemento se agrega al inicio
+     * de la lista. Si el índice es mayor o igual que el número de elementos en
+     * la lista, el elemento se agrega al fina de la misma. En otro caso,
+     * después de mandar llamar el método, el elemento tendrá el índice que se
+     * especifica en la lista.
+     * @param i el índice dónde insertar el elemento. Si es menor que 0 el
+     *          elemento se agrega al inicio de la lista, y si es mayor o igual
+     *          que el número de elementos en la lista se agrega al final.
+     * @param elemento el elemento a insertar.
+     * @throws IllegalArgumentException si <code>elemento</code> es
+     *         <code>null</code>.
+     */
+    public void inserta(int i, T elemento) {
+        // Aquí va su código.
+        if(elemento == null){
+            throw new IllegalArgumentException();
+        } 
+
+        if(i<1){
+            agregaInicio(elemento);
+        } else if(i>longitud-1){
+            agregaFinal(elemento);
+        } else {
+            Nodo n = new Nodo(elemento);
+            longitud++;
+
+            int indice = 0;
+            Nodo c = cabeza;
+            Nodo e = new Nodo(elemento);
+            while ( c != null ) {
+                if ( indice == i ){
+                    e = c;
+                };
+                c = c.siguiente;
+                indice++;
+                }
+
+
+            Nodo z = e;
+            Nodo y = z.anterior;
+
+            n.siguiente = z;
+            z.anterior = n;
+
+            
+            n.anterior = y;
+            y.siguiente = n;
+
+        }
+    }
+
+    /**
+     * Elimina un elemento de la lista. Si el elemento no está contenido en la
+     * lista, el método no la modifica.
+     * @param elemento el elemento a eliminar.
+     */
+    @Override public void elimina(T elemento) {
+        // Aquí va su código.
+        Nodo c = cabeza; 
+
+        while(c != null){
+            if(c.elemento.equals(elemento))
+                break;
+
+                c = c.siguiente;
+        }
+
+        if(c == null){
+            return;
+        }
+
+        longitud--;
+            
+        if(c.anterior == null){
+            cabeza = c.siguiente;
+        } else {
+            c.anterior.siguiente = c.siguiente;
+        }
+            
+        if(c.siguiente == null){
+            rabo = c.anterior;
+        } else {
+            c.siguiente.anterior = c.anterior;
+        }
+    }
+
+    /**
+     * Elimina el primer elemento de la lista y lo regresa.
+     * @return el primer elemento de la lista antes de eliminarlo.
+     * @throws NoSuchElementException si la lista es vacía.
+     */
+    public T eliminaPrimero() {
+        // Aquí va su código.
+        if(cabeza == null){
+            throw new NoSuchElementException();
+        }
+
+        longitud--;
+        T d = cabeza.elemento;
+        cabeza = cabeza.siguiente;
+
+        if(cabeza != null){
+            cabeza.anterior = null;
+        } else {
+            rabo = null;
+        }
+        
+        return d;
+    }
+
+    /**
+     * Elimina el último elemento de la lista y lo regresa.
+     * @return el último elemento de la lista antes de eliminarlo.
+     * @throws NoSuchElementException si la lista es vacía.
+     */
+    public T eliminaUltimo() {
+        // Aquí va su código.
+        if(rabo == null){
+            throw new NoSuchElementException();
+        }
+
+        longitud--;
+        T d = rabo.elemento;
+        rabo = rabo.anterior;
+
+        if(rabo != null){
+            rabo.siguiente = null;
+        } else {
+            cabeza = null;
+        }
+        
+        return d;
+    }
+
+    /**
+     * Nos dice si un elemento está en la lista.
+     * @param elemento el elemento que queremos saber si está en la lista.
+     * @return <code>true</code> si <code>elemento</code> está en la lista,
+     *         <code>false</code> en otro caso.
+     */
+    @Override public boolean contiene(T elemento) {
+        // Aquí va su código.
+        Nodo c = cabeza;
+
+	    while(c != null) {
+	    	if(c.elemento.equals(elemento)){
+                return true;
+            } 
+		c = c.siguiente;
+	    }
+        return false;
+    }
+
+    /**
+     * Regresa la reversa de la lista.
+     * @return una nueva lista que es la reversa la que manda llamar el método.
+     */
+    public Lista<T> reversa() {
+        // Aquí va su código.
+        Nodo c = cabeza;
+        Lista<T> reversa = new Lista<T>();
+
+        while(c != null){
+            reversa.agregaInicio(c.elemento);
+            c = c.siguiente;
+        }
+
+        return reversa;
+    }
+
+    /**
+     * Regresa una copia de la lista. La copia tiene los mismos elementos que la
+     * lista que manda llamar el método, en el mismo orden.
+     * @return una copiad de la lista.
+     */
+    public Lista<T> copia() {
+        // Aquí va su código.
+        Nodo c = cabeza;
+        Lista<T> copia = new Lista<T>();
+
+        while(c != null){
+            copia.agregaFinal(c.elemento);
+            c = c.siguiente;
+        }
+
+        return copia;
+    }
+
+    /**
+     * Limpia la lista de elementos, dejándola vacía.
+     */
+    @Override public void limpia() {
+        // Aquí va su código.
+        cabeza = null;
+        rabo = null;
+        longitud = 0;
+    }
+
+    /**
+     * Regresa el primer elemento de la lista.
+     * @return el primer elemento de la lista.
+     * @throws NoSuchElementException si la lista es vacía.
+     */
+    public T getPrimero() {
+        // Aquí va su código.
+        if(cabeza == null){
+            throw new NoSuchElementException();
+        } 
+        return cabeza.elemento;
+    }
+
+    /**
+     * Regresa el último elemento de la lista.
+     * @return el primer elemento de la lista.
+     * @throws NoSuchElementException si la lista es vacía.
+     */
+    public T getUltimo() {
+        // Aquí va su código.
+        if(rabo == null){
+            throw new NoSuchElementException();
+        } 
+        return rabo.elemento;
+    }
+
+    /**
+     * Regresa el <em>i</em>-ésimo elemento de la lista.
+     * @param i el índice del elemento que queremos.
+     * @return el <em>i</em>-ésimo elemento de la lista.
+     * @throws ExcepcionIndiceInvalido si <em>i</em> es menor que cero o mayor o
+     *         igual que el número de elementos en la lista.
+     */
+    public T get(int i) {
+        // Aquí va su código.
+        if(i<0 || i>getElementos()-1){
+            throw new ExcepcionIndiceInvalido();
+        } 
+
+        int indice = 0;
+        Nodo c = cabeza;
+        Nodo e = cabeza.siguiente;
+
+        while(c != null){
+            if(indice == i){               
+                e = c;
+              };
+             c = c.siguiente;
+             indice++;
+            }
+
+        return e.elemento;
+    }
+
+    /**
+     * Regresa el índice del elemento recibido en la lista.
+     * @param elemento el elemento del que se busca el índice.
+     * @return el índice del elemento recibido en la lista, o -1 si el elemento
+     *         no está contenido en la lista.
+     */
+    public int indiceDe(T elemento) {
+        // Aquí va su código.
+        int indice = 0;
+        Nodo c = cabeza;
+        while(c != null){
+            if(c.elemento == elemento){
+                return indice;
+            }
+            c = c.siguiente;
+            indice++;
+        }
+
+        return -1;
+    }
+
+    /**
+     * Regresa una representación en cadena de la lista.
+     * @return una representación en cadena de la lista.
+     */
+    @Override public String toString() {
+        // Aquí va su código.
+        if(cabeza == null){
+            return "[]";
+        }           
+        String c = "[";       
+        for(int a = 0; a < longitud - 1; a++)
+            c += String.format("%s, ", this.get(a));
+            c += String.format("%s]", this.get(longitud-1));
+            return c;
+    }
+
+    /**
+     * Nos dice si la lista es igual al objeto recibido.
+     * @param objeto el objeto con el que hay que comparar.
+     * @return <code>true</code> si la lista es igual al objeto recibido;
+     *         <code>false</code> en otro caso.
+     */
+    @Override public boolean equals(Object objeto) {
+        if (objeto == null || getClass() != objeto.getClass())
+            return false;
+        @SuppressWarnings("unchecked") Lista<T> lista = (Lista<T>)objeto;
+        // Aquí va su código.
+        if(getLongitud() != lista.getLongitud()){
+            return false;
+        }else{
+            Nodo c = cabeza;
+            Nodo d = lista.cabeza;
+
+            while(c != null){
+                if(!c.elemento.equals(d.elemento)){
+                    return false;
+                }
+                c = c.siguiente;
+                d = d.siguiente;
+            }
+            return true;
+        }
+    }
+
+    /**
+     * Regresa un iterador para recorrer la lista en una dirección.
+     * @return un iterador para recorrer la lista en una dirección.
+     */
+    @Override public Iterator<T> iterator() {
+        return new Iterador();
+    }
+
+    /**
+     * Regresa un iterador para recorrer la lista en ambas direcciones.
+     * @return un iterador para recorrer la lista en ambas direcciones.
+     */
+    public IteradorLista<T> iteradorLista() {
+        return new Iterador();
+    }
+
+    /**
+     * Regresa una copia de la lista, pero ordenada. Para poder hacer el
+     * ordenamiento, el método necesita una instancia de {@link Comparator} para
+     * poder comparar los elementos de la lista.
+     * @param comparador el comparador que la lista usará para hacer el
+     *                   ordenamiento.
+     * @return una copia de la lista, pero ordenada.
+     */
+    public Lista<T> mergeSort(Comparator<T> comparador) {
+        // Aquí va su código.
+        if(longitud <= 1){
+            return copia();
+        }
+            
+        int mitad = (longitud / 2);
+        Lista<T> primeraMitad = generaListaChiquita(0, mitad).mergeSort(comparador);
+        Lista<T> segundaMitad = generaListaChiquita(mitad, longitud).mergeSort(comparador);
+
+        Lista<T> listaOrdenada = new Lista<T>();
+        Nodo cabezitaIzquierda = primeraMitad.cabeza;
+        Nodo cabezitaDerecha = segundaMitad.cabeza;
+
+        while(cabezitaIzquierda != null && cabezitaDerecha != null){
+            if(comparador.compare(cabezitaIzquierda.elemento, cabezitaDerecha.elemento) <= 0){
+                listaOrdenada.agregaFinal(cabezitaIzquierda.elemento);
+                cabezitaIzquierda = cabezitaIzquierda.siguiente;
+            }else{
+                listaOrdenada.agregaFinal(cabezitaDerecha.elemento);
+                cabezitaDerecha = cabezitaDerecha.siguiente;
+            }
+        }
+
+        while (cabezitaIzquierda != null) {
+            listaOrdenada.agregaFinal(cabezitaIzquierda.elemento);
+            cabezitaIzquierda = cabezitaIzquierda.siguiente;
+        }
+
+        while (cabezitaDerecha != null) {
+            listaOrdenada.agregaFinal(cabezitaDerecha.elemento);
+            cabezitaDerecha = cabezitaDerecha.siguiente;
+        }
+
+        return listaOrdenada;
+    }
+
+    private Lista<T> generaListaChiquita(int i, int j) {
+        Lista<T> listaChiquita = new Lista<T>();
+
+        int indice = 0;
+        Nodo cabezita = cabeza;
+
+        while (indice != i){
+            cabezita = cabezita.siguiente;
+            indice++;
+        }
+            
+        while (cabezita != null && i<j) {
+            listaChiquita.agregaFinal(cabezita.elemento);
+            cabezita = cabezita.siguiente;
+            i++;
+        }
+
+        return listaChiquita;
+    }
+
+    /**
+     * Regresa una copia de la lista recibida, pero ordenada. La lista recibida
+     * tiene que contener nada más elementos que implementan la interfaz {@link
+     * Comparable}.
+     * @param <T> tipo del que puede ser la lista.
+     * @param lista la lista que se ordenará.
+     * @return una copia de la lista recibida, pero ordenada.
+     */
+    public static <T extends Comparable<T>>
+    Lista<T> mergeSort(Lista<T> lista) {
+        return lista.mergeSort((a, b) -> a.compareTo(b));
+    }
+
+    /**
+     * Busca un elemento en la lista ordenada, usando el comparador recibido. El
+     * método supone que la lista está ordenada usando el mismo comparador.
+     * @param elemento el elemento a buscar.
+     * @param comparador el comparador con el que la lista está ordenada.
+     * @return <code>true</code> si el elemento está contenido en la lista,
+     *         <code>false</code> en otro caso.
+     */
+    public boolean busquedaLineal(T elemento, Comparator<T> comparador) {
+        // Aquí va su código.
+        Nodo cabezita = cabeza;
+
+        while(cabezita != null){           
+		    if(comparador.compare(cabezita.elemento, elemento) == 0){
+                return true;
+            }
+            cabezita = cabezita.siguiente;
+	    } 
+	    
+	    return false;
+    }
+
+    /**
+     * Busca un elemento en una lista ordenada. La lista recibida tiene que
+     * contener nada más elementos que implementan la interfaz {@link
+     * Comparable}, y se da por hecho que está ordenada.
+     * @param <T> tipo del que puede ser la lista.
+     * @param lista la lista donde se buscará.
+     * @param elemento el elemento a buscar.
+     * @return <code>true</code> si el elemento está contenido en la lista,
+     *         <code>false</code> en otro caso.
+     */
+    public static <T extends Comparable<T>>
+    boolean busquedaLineal(Lista<T> lista, T elemento) {
+        return lista.busquedaLineal(elemento, (a, b) -> a.compareTo(b));
+    }
+}
diff --git a/src/main/java/mx/unam/ciencias/edd/MeteSaca.java b/src/main/java/mx/unam/ciencias/edd/MeteSaca.java
index 8864077..1c4fac2 100644
--- a/src/main/java/mx/unam/ciencias/edd/MeteSaca.java
+++ b/src/main/java/mx/unam/ciencias/edd/MeteSaca.java
@@ -1,81 +1,124 @@
-package mx.unam.ciencias.edd;
-
-import java.util.NoSuchElementException;
-
-/**
- * Clase abtracta para estructuras lineales restringidas a operaciones
- * mete/saca/mira.
- */
-public abstract class MeteSaca<T> {
-
-    /**
-     * Clase interna protegida para nodos.
-     */
-    protected class Nodo {
-        /** El elemento del nodo. */
-        public T elemento;
-        /** El siguiente nodo. */
-        public Nodo siguiente;
-
-        /**
-         * Construye un nodo con un elemento.
-         * @param elemento el elemento del nodo.
-         */
-        public Nodo(T elemento) {
-            // Aquí va su código.
-        }
-    }
-
-    /** La cabeza de la estructura. */
-    protected Nodo cabeza;
-    /** El rabo de la estructura. */
-    protected Nodo rabo;
-
-    /**
-     * Agrega un elemento al extremo de la estructura.
-     * @param elemento el elemento a agregar.
-     */
-    public abstract void mete(T elemento);
-
-    /**
-     * Elimina el elemento en un extremo de la estructura y lo regresa.
-     * @return el elemento en un extremo de la estructura.
-     * @throws NoSuchElementException si la estructura está vacía.
-     */
-    public T saca() {
-        // Aquí va su código.
-    }
-
-    /**
-     * Nos permite ver el elemento en un extremo de la estructura, sin sacarlo
-     * de la misma.
-     * @return el elemento en un extremo de la estructura.
-     * @throws NoSuchElementException si la estructura está vacía.
-     */
-    public T mira() {
-        // Aquí va su código.
-    }
-
-    /**
-     * Nos dice si la estructura está vacía.
-     * @return <code>true</code> si la estructura no tiene elementos,
-     *         <code>false</code> en otro caso.
-     */
-    public boolean esVacia() {
-        // Aquí va su código.
-    }
-
-    /**
-     * Compara la estructura con un objeto.
-     * @param object el objeto con el que queremos comparar la estructura.
-     * @return <code>true</code> si el objeto recibido es una instancia de la
-     *         misma clase que la estructura, y sus elementos son iguales en el
-     *         mismo orden; <code>false</code> en otro caso.
-     */
-    @Override public boolean equals(Object object) {
-        if (object == null || getClass() != object.getClass())
-            return false;
-        @SuppressWarnings("unchecked") MeteSaca<T> m = (MeteSaca<T>)object;
-        // Aquí va su código.
-    }
-}
+package mx.unam.ciencias.edd;
+
+import java.util.NoSuchElementException;
+
+/**
+ * Clase abtracta para estructuras lineales restringidas a operaciones
+ * mete/saca/mira.
+ */
+public abstract class MeteSaca<T> {
+
+    /**
+     * Clase interna protegida para nodos.
+     */
+    protected class Nodo {
+        /** El elemento del nodo. */
+        public T elemento;
+        /** El siguiente nodo. */
+        public Nodo siguiente;
+
+        /**
+         * Construye un nodo con un elemento.
+         * @param elemento el elemento del nodo.
+         */
+        public Nodo(T elemento) {
+            // Aquí va su código.
+            this.elemento = elemento;
+        }
+    }
+
+    /** La cabeza de la estructura. */
+    protected Nodo cabeza;
+    /** El rabo de la estructura. */
+    protected Nodo rabo;
+
+    /**
+     * Agrega un elemento al extremo de la estructura.
+     * @param elemento el elemento a agregar.
+     */
+    public abstract void mete(T elemento);
+
+    /**
+     * Elimina el elemento en un extremo de la estructura y lo regresa.
+     * @return el elemento en un extremo de la estructura.
+     * @throws NoSuchElementException si la estructura está vacía.
+     */
+    public T saca() {
+        // Aquí va su código.
+        if(cabeza == null){
+            throw new NoSuchElementException();
+        }
+
+        T cabezita = cabeza.elemento;
+        if(cabeza == rabo){
+            cabeza = rabo = null;
+        }else{
+            cabeza = cabeza.siguiente;
+        }
+        return cabezita;
+    }
+
+    /**
+     * Nos permite ver el elemento en un extremo de la estructura, sin sacarlo
+     * de la misma.
+     * @return el elemento en un extremo de la estructura.
+     * @throws NoSuchElementException si la estructura está vacía.
+     */
+    public T mira() {
+        // Aquí va su código.
+        if(rabo == null){
+            throw new NoSuchElementException();
+        }
+
+        T cabezita = cabeza.elemento;
+
+        return cabezita;
+    }
+
+    /**
+     * Nos dice si la estructura está vacía.
+     * @return <code>true</code> si la estructura no tiene elementos,
+     *         <code>false</code> en otro caso.
+     */
+    public boolean esVacia() {
+        // Aquí va su código.
+        if(cabeza == null){
+            return true;
+        } else {
+            return false;
+        }
+    }
+
+    /**
+     * Compara la estructura con un objeto.
+     * @param object el objeto con el que queremos comparar la estructura.
+     * @return <code>true</code> si el objeto recibido es una instancia de la
+     *         misma clase que la estructura, y sus elementos son iguales en el
+     *         mismo orden; <code>false</code> en otro caso.
+     */
+    @Override public boolean equals(Object object) {
+        if (object == null || getClass() != object.getClass())
+            return false;
+        @SuppressWarnings("unchecked") MeteSaca<T> m = (MeteSaca<T>)object;
+        // Aquí va su código.
+        Nodo c = cabeza;
+        Nodo d = m.cabeza;
+
+        while(c != null){
+
+            if(d == null){
+                return false;
+            }
+
+            if(!c.elemento.equals(d.elemento)){
+                return false;
+            }
+			
+            c = c.siguiente;
+            d = d.siguiente;
+
+        }
+        
+        return true;
+    }
+}
diff --git a/src/main/java/mx/unam/ciencias/edd/MonticuloArreglo.java b/src/main/java/mx/unam/ciencias/edd/MonticuloArreglo.java
index 46f7cb7..f8a832d 100644
--- a/src/main/java/mx/unam/ciencias/edd/MonticuloArreglo.java
+++ b/src/main/java/mx/unam/ciencias/edd/MonticuloArreglo.java
@@ -28,6 +28,7 @@ public class MonticuloArreglo<T extends ComparableIndexable<T>>
      */
     public MonticuloArreglo(Coleccion<T> coleccion) {
         // Aquí va su código.
+        this(coleccion, coleccion.getElementos());
     }
 
     /**
@@ -38,6 +39,14 @@ public class MonticuloArreglo<T extends ComparableIndexable<T>>
      */
     public MonticuloArreglo(Iterable<T> iterable, int n) {
         // Aquí va su código.
+        arreglo = nuevoArreglo(n);
+	    elementos = n;
+	    
+	    int i = 0;
+	    for(T e : iterable){
+		    arreglo[i] = e;
+		    e.setIndice(i++);
+	    }
     }
 
     /**
@@ -47,6 +56,28 @@ public class MonticuloArreglo<T extends ComparableIndexable<T>>
      */
     @Override public T elimina() {
         // Aquí va su código.
+        if(elementos == 0){
+            throw new IllegalStateException();
+        }
+        
+        T minimo = null;
+        for(T elemento : arreglo){
+            if(minimo == null && elemento != null){
+                minimo = elemento;
+            }else if(minimo != null && elemento != null && elemento.compareTo(minimo) < 0){
+                minimo = elemento;
+            }
+        }
+            
+            
+        int indice = minimo.getIndice();
+        minimo.setIndice(-1);
+
+        arreglo[indice] = null;
+        elementos--;
+
+        return minimo;
+
     }
 
     /**
@@ -58,6 +89,11 @@ public class MonticuloArreglo<T extends ComparableIndexable<T>>
      */
     @Override public T get(int i) {
         // Aquí va su código.
+        if(i < 0 || i > elementos - 1){
+            throw new NoSuchElementException();
+        }
+        
+	    return arreglo[i];
     }
 
     /**
@@ -67,6 +103,11 @@ public class MonticuloArreglo<T extends ComparableIndexable<T>>
      */
     @Override public boolean esVacia() {
         // Aquí va su código.
+        if(elementos == 0){
+            return true;
+        }else{
+            return false;
+        }
     }
 
     /**
@@ -75,5 +116,6 @@ public class MonticuloArreglo<T extends ComparableIndexable<T>>
      */
     @Override public int getElementos() {
         // Aquí va su código.
+        return elementos;
     }
 }
diff --git a/src/main/java/mx/unam/ciencias/edd/MonticuloMinimo.java b/src/main/java/mx/unam/ciencias/edd/MonticuloMinimo.java
index e6f3a05..49b8143 100644
--- a/src/main/java/mx/unam/ciencias/edd/MonticuloMinimo.java
+++ b/src/main/java/mx/unam/ciencias/edd/MonticuloMinimo.java
@@ -18,11 +18,17 @@ public class MonticuloMinimo<T extends ComparableIndexable<T>>
         /* Nos dice si hay un siguiente elemento. */
         @Override public boolean hasNext() {
             // Aquí va su código.
+            return elementos > indice;
         }
 
         /* Regresa el siguiente elemento. */
         @Override public T next() {
             // Aquí va su código.
+            if (elementos <= indice){
+                throw new NoSuchElementException();
+            }
+
+            return arbol[indice++];
         }
     }
 
@@ -38,21 +44,26 @@ public class MonticuloMinimo<T extends ComparableIndexable<T>>
         /* Crea un nuevo comparable indexable. */
         public Adaptador(T elemento) {
             // Aquí va su código.
+            this.elemento = elemento;
+            indice = -1;
         }
 
         /* Regresa el índice. */
         @Override public int getIndice() {
             // Aquí va su código.
+            return indice;
         }
 
         /* Define el índice. */
         @Override public void setIndice(int indice) {
             // Aquí va su código.
+            this.indice = indice;
         }
 
         /* Compara un adaptador con otro. */
         @Override public int compareTo(Adaptador<T> adaptador) {
             // Aquí va su código.
+            return elemento.compareTo(adaptador.elemento);
         }
     }
 
@@ -75,6 +86,7 @@ public class MonticuloMinimo<T extends ComparableIndexable<T>>
      */
     public MonticuloMinimo() {
         // Aquí va su código.
+        arbol = nuevoArreglo(100);
     }
 
     /**
@@ -87,6 +99,7 @@ public class MonticuloMinimo<T extends ComparableIndexable<T>>
      */
     public MonticuloMinimo(Coleccion<T> coleccion) {
         // Aquí va su código.
+        this(coleccion, coleccion.getElementos());
     }
 
     /**
@@ -100,6 +113,60 @@ public class MonticuloMinimo<T extends ComparableIndexable<T>>
      */
     public MonticuloMinimo(Iterable<T> iterable, int n) {
         // Aquí va su código.
+        arbol = nuevoArreglo(n);
+
+        for(T elemento : iterable){
+            agregaPorIndice(elemento, elementos++);
+        }
+            
+
+        for(int j = n/2 - 1; j >= 0; j--){
+            acomodaAbajo(j);
+        }
+            
+    }
+
+    private void agregaPorIndice(T elemento, int indice) {
+        arbol[indice] = elemento;
+        elemento.setIndice(indice);
+    }
+
+    private void acomodaAbajo(int i) {
+        int hijoIzquierdo = 2 * i + 1;
+        int hijoDerecho = 2 * i + 2;
+
+        int indiceMenor = i;
+        if(hijoIzquierdo < elementos && arbol[hijoIzquierdo].compareTo(arbol[indiceMenor]) < 0){
+            indiceMenor = hijoIzquierdo;
+        }
+            
+        if(hijoDerecho < elementos && arbol[hijoDerecho].compareTo(arbol[indiceMenor]) < 0){
+            indiceMenor = hijoDerecho;
+        }
+
+        if(indiceMenor != i){
+            catafixia(i, indiceMenor);
+            acomodaAbajo(indiceMenor);
+        }
+    }
+
+    private boolean validezIndice(int i) {
+        if(i < 0 || i >= elementos){
+            return false;
+        }else{
+            return true;
+        }
+
+    }
+
+    private void catafixia(int x, int y) {
+        T temporal = arbol[x];
+
+        arbol[x] = arbol[y];
+        arbol[y] = temporal;
+
+        arbol[x].setIndice(x);
+        arbol[y].setIndice(y);
     }
 
     /**
@@ -108,6 +175,25 @@ public class MonticuloMinimo<T extends ComparableIndexable<T>>
      */
     @Override public void agrega(T elemento) {
         // Aquí va su código.
+        if(arbol.length == elementos){
+            T[] nuevoArbol = nuevoArreglo(elementos * 2);
+            for (int i = 0; i < elementos; i++)
+                nuevoArbol[i] = arbol[i];
+            arbol = nuevoArbol;
+        }
+
+        agregaPorIndice(elemento, elementos);
+        elementos++;
+        acomodaArriba(elementos - 1);
+    }
+
+    private void acomodaArriba(int i) {
+        int padre = (i - 1)/2;
+
+        if (i > 0 && arbol[i].compareTo(arbol[padre]) < 0) {
+            catafixia(i, padre);
+            acomodaArriba(padre);
+        }
     }
 
     /**
@@ -117,6 +203,19 @@ public class MonticuloMinimo<T extends ComparableIndexable<T>>
      */
     @Override public T elimina() {
         // Aquí va su código.
+        if(elementos == 0){
+            throw new IllegalStateException();
+        }
+        
+        T temporal = arbol[0];
+        catafixia(0, elementos - 1);
+        arbol[elementos - 1].setIndice(-1);
+
+        elementos--;
+        acomodaAbajo(0);
+
+        return temporal;
+		
     }
 
     /**
@@ -125,8 +224,24 @@ public class MonticuloMinimo<T extends ComparableIndexable<T>>
      */
     @Override public void elimina(T elemento) {
         // Aquí va su código.
+        if(elemento.getIndice() < 0 || elemento.getIndice() >= elementos){
+            return;
+        }
+            
+        int indice = elemento.getIndice();
+        catafixia(indice, elementos - 1);
+
+        arbol[elementos - 1].setIndice(-1);
+        elementos--;
+
+        if(indice < elementos){
+            reordena(arbol[indice]);
+        }
+            
     }
 
+    
+
     /**
      * Nos dice si un elemento está contenido en el montículo.
      * @param elemento el elemento que queremos saber si está contenido.
@@ -135,6 +250,11 @@ public class MonticuloMinimo<T extends ComparableIndexable<T>>
      */
     @Override public boolean contiene(T elemento) {
         // Aquí va su código.
+        if(elemento.getIndice() < 0 || elemento.getIndice() >= elementos){
+            return false;
+        }
+
+        return arbol[elemento.getIndice()].equals(elemento);
     }
 
     /**
@@ -144,6 +264,12 @@ public class MonticuloMinimo<T extends ComparableIndexable<T>>
      */
     @Override public boolean esVacia() {
         // Aquí va su código.
+        if(elementos == 0){
+            return true;
+        }else{
+            return false;
+        }
+            
     }
 
     /**
@@ -151,6 +277,7 @@ public class MonticuloMinimo<T extends ComparableIndexable<T>>
      */
     @Override public void limpia() {
         // Aquí va su código.
+        elementos = 0;
     }
 
    /**
@@ -159,6 +286,10 @@ public class MonticuloMinimo<T extends ComparableIndexable<T>>
      */
     @Override public void reordena(T elemento) {
         // Aquí va su código.
+        int indice = elemento.getIndice();
+        
+        acomodaArriba(indice);
+        acomodaAbajo(indice);
     }
 
     /**
@@ -178,6 +309,11 @@ public class MonticuloMinimo<T extends ComparableIndexable<T>>
      */
     @Override public T get(int i) {
         // Aquí va su código.
+        if(!validezIndice(i)){
+            throw new NoSuchElementException();
+        }
+
+	    return arbol[i];
     }
 
     /**
@@ -186,6 +322,13 @@ public class MonticuloMinimo<T extends ComparableIndexable<T>>
      */
     @Override public String toString() {
         // Aquí va su código.
+        String cadenita = "";
+
+        for (T elemento : arbol){
+            cadenita += elemento.toString() + ", ";
+        }
+
+        return cadenita;
     }
 
     /**
@@ -200,6 +343,18 @@ public class MonticuloMinimo<T extends ComparableIndexable<T>>
         @SuppressWarnings("unchecked") MonticuloMinimo<T> monticulo =
             (MonticuloMinimo<T>)objeto;
         // Aquí va su código.
+        if(monticulo.elementos != elementos){
+            return false;
+        }
+
+        for(int i = 0; i < elementos; i++){
+            if(!arbol[i].equals(monticulo.arbol[i])){
+                return false;
+            }
+        }
+    
+        return true;
+
     }
 
     /**
@@ -220,5 +375,21 @@ public class MonticuloMinimo<T extends ComparableIndexable<T>>
     public static <T extends Comparable<T>>
     Lista<T> heapSort(Coleccion<T> coleccion) {
         // Aquí va su código.
+        Lista<Adaptador<T>> listaPrimera = new Lista<>();
+        Lista<T> listaSegunda = new Lista<>();
+
+        for(T elemento : coleccion){
+            listaPrimera.agrega(new Adaptador<T>(elemento));
+        }
+
+        MonticuloMinimo<Adaptador<T>> monticulo = new MonticuloMinimo<>(listaPrimera);
+
+        while(!monticulo.esVacia()){
+            Adaptador<T> eliminado = monticulo.elimina();
+            listaSegunda.agrega(eliminado.elemento);
+        }
+
+        return listaSegunda;
+
     }
 }
diff --git a/src/main/java/mx/unam/ciencias/edd/Pila.java b/src/main/java/mx/unam/ciencias/edd/Pila.java
index fc800e7..bee04c0 100644
--- a/src/main/java/mx/unam/ciencias/edd/Pila.java
+++ b/src/main/java/mx/unam/ciencias/edd/Pila.java
@@ -1,25 +1,49 @@
-package mx.unam.ciencias.edd;
-
-/**
- * Clase para pilas genéricas.
- */
-public class Pila<T> extends MeteSaca<T> {
-
-    /**
-     * Regresa una representación en cadena de la pila.
-     * @return una representación en cadena de la pila.
-     */
-    @Override public String toString() {
-        // Aquí va su código.
-    }
-
-    /**
-     * Agrega un elemento al tope de la pila.
-     * @param elemento el elemento a agregar.
-     * @throws IllegalArgumentException si <code>elemento</code> es
-     *         <code>null</code>.
-     */
-    @Override public void mete(T elemento) {
-        // Aquí va su código.
-    }
-}
+package mx.unam.ciencias.edd;
+
+/**
+ * Clase para pilas genéricas.
+ */
+public class Pila<T> extends MeteSaca<T> {
+
+    /**
+     * Regresa una representación en cadena de la pila.
+     * @return una representación en cadena de la pila.
+     */
+    @Override public String toString() {
+        // Aquí va su código.
+        if(esVacia()){
+            return "";
+        }
+
+        String libros = "";
+        Nodo libro = cabeza;
+
+        while(libro != null){
+            libros += libro.elemento + "\n";
+            libro = libro.siguiente;
+        }
+
+        return libros;
+    }
+
+    /**
+     * Agrega un elemento al tope de la pila.
+     * @param elemento el elemento a agregar.
+     * @throws IllegalArgumentException si <code>elemento</code> es
+     *         <code>null</code>.
+     */
+    @Override public void mete(T elemento) {
+        // Aquí va su código.
+        if(elemento == null){
+            throw new IllegalArgumentException();
+        }
+
+        Nodo d = new Nodo(elemento);
+        if(cabeza == null){
+            cabeza = rabo = d;
+        }else{           
+            d.siguiente = cabeza;
+            cabeza = d;
+            }
+    }
+}
diff --git a/src/main/java/mx/unam/ciencias/edd/ValorIndexable.java b/src/main/java/mx/unam/ciencias/edd/ValorIndexable.java
index 15ba2bf..fd78a76 100644
--- a/src/main/java/mx/unam/ciencias/edd/ValorIndexable.java
+++ b/src/main/java/mx/unam/ciencias/edd/ValorIndexable.java
@@ -20,6 +20,9 @@ public class ValorIndexable<T>
      */
     public ValorIndexable(T elemento, double valor) {
         // Aquí va su código.
+        this.elemento = elemento;
+        this.valor = valor;
+        indice = -1;
     }
 
     /**
@@ -28,6 +31,7 @@ public class ValorIndexable<T>
      */
     public T getElemento() {
         // Aquí va su código.
+        return elemento;
     }
 
     /**
@@ -39,6 +43,15 @@ public class ValorIndexable<T>
      */
     @Override public int compareTo(ValorIndexable<T> valorIndexable) {
         // Aquí va su código.
+        if(valor == valorIndexable.valor){
+            return 0;
+        } 
+		    
+	    if(valor < valorIndexable.valor){
+            return -1;
+        }
+		    
+	    return 1;
     }
 
     /**
@@ -47,6 +60,7 @@ public class ValorIndexable<T>
      */
     @Override public void setIndice(int indice) {
         // Aquí va su código.
+        this.indice = indice;
     }
 
     /**
@@ -55,6 +69,7 @@ public class ValorIndexable<T>
      */
     @Override public int getIndice() {
         // Aquí va su código.
+        return indice;
     }
 
     /**
@@ -63,6 +78,7 @@ public class ValorIndexable<T>
      */
     public void setValor(double valor) {
         // Aquí va su código.
+        this.valor = valor;
     }
 
     /**
@@ -71,6 +87,7 @@ public class ValorIndexable<T>
      */
     public double getValor() {
         // Aquí va su código.
+        return valor;
     }
 
     /**
@@ -85,6 +102,7 @@ public class ValorIndexable<T>
         @SuppressWarnings("unchecked") ValorIndexable<T> valorIndexable =
             (ValorIndexable<T>)objeto;
         // Aquí va su código.
+        return this.elemento.equals(valorIndexable.elemento) && this.valor == valorIndexable.valor;
     }
 
     /**
@@ -93,5 +111,6 @@ public class ValorIndexable<T>
      */
     @Override public String toString() {
         // Aquí va su código.
+        return String.format("%s:%2.9f", elemento, valor);
     }
 }
